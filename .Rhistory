ggplot(aes(x = Income, y = Shopping)) +
geom_point() +
geom_smooth(method = "lm")
p2 <- mydatc2_case |>
ggplot(aes(x = Age, y = Shopping)) +
geom_point() +
geom_smooth(method = "lm")
p3 <- mydatc2_case |>
ggplot(aes(x = Gender, y = Shopping)) +
geom_point() +
geom_smooth(method = "lm")
p1 + p2 + p3
mydatc2_case |>
select(-"ID") |>
cor() |>
corrplot(method = "number", type = "lower", order = "FPC")
# get unstandardized predicted and residual values
unstandardizedPredicted <- predict(lm_fit_a2, new_data = mydatc2_case) |> pull(.pred)
unstandardizedResiduals <- summary_a2$residuals
# get standardized values
standardizedPredicted <- (unstandardizedPredicted - mean(unstandardizedPredicted)) / sd(unstandardizedPredicted)
standardizedResiduals <- (unstandardizedResiduals - mean(unstandardizedResiduals)) / sd(unstandardizedResiduals)
tibble(standardizedPredicted, standardizedResiduals) |>
ggplot(aes(x = standardizedPredicted, y = standardizedResiduals)) +
geom_point() +
geom_hline(yintercept = 0) +
labs(title = "Tukey-Anscombe-Plot (Modell 2)",
y = "Residuen (standardisiert)",
x = "Geschätzte Werte (standardisiert)")
# get unstandardized predicted and residual values
unstandardizedPredicted1 <- predict(lm_fit_a1, new_data = mydatc2_case) |> pull(.pred)
unstandardizedResiduals1 <- summary_a1$residuals
# get standardized values
standardizedPredicted1 <- (unstandardizedPredicted1 - mean(unstandardizedPredicted1)) / sd(unstandardizedPredicted1)
standardizedResiduals1 <- (unstandardizedResiduals1 - mean(unstandardizedResiduals1)) / sd(unstandardizedResiduals1)
tibble(standardizedPredicted1, standardizedResiduals1) |>
ggplot(aes(x = standardizedPredicted1, y = standardizedResiduals1)) +
geom_point() +
geom_hline(yintercept = 0) +
labs(title = "Tukey-Anscombe-Plot (Modell 1)",
y = "Residuen (standardisiert)",
x = "Geschätzte Werte (standardisiert)")
tibble(standardizedResiduals) |>
ggplot(aes(x = standardizedResiduals)) +
geom_histogram(binwidth = 0.1) +
labs(title = "Histogramm der Residuen (standardisiert)",
x = "Residuen (standardisiert)",
y = "Anzahl")
tibble(standardizedResiduals) |>
ggplot(aes(sample = standardizedResiduals)) +
stat_qq_line() +
stat_qq_point() +
labs(title = "QQ-Plot der standardisierten Residuen",
x = "Quantile der Normalverteilung",
y = "Quantile der Residuen")
vif(lm_fit_a2 |> extract_fit_engine())
# Observed and standardized values
mydatc2t <- data.frame(Period = c(1:12),
Sales = c(2596,2709,2552,3004,3076,2513,2626,3120,2751,2965,2818,3171),
Time = c(1:12),
d1 = c(1,0,0,0,1,0,0,0,1,0,0,0),
d2 = c(0,1,0,0,0,1,0,0,0,1,0,0),
d3 = c(0,0,1,0,0,0,1,0,0,0,1,0),
d4 = c(0,0,0,1,0,0,0,1,0,0,0,1))
# Set labels
var.labels <- c(Period = "i",
Sales = "1000 units",
Time = "t [Quarter]",
d1 = "d1",
d2 = "d2",
d3 = "d3",
d4 = "d4")
Hmisc::label(mydatc2t) <- as.list(var.labels[match(names(mydatc2t), names(var.labels))])
#  Display generated data for verification; # Structure of the generated data
print(mydatc2t)
mydatc2t %>%
ggplot() +
aes(x = Time, y = Sales) +
geom_point() + geom_smooth(method=lm)
reg <- lm(Sales ~ Time, data = mydatc2t)
summary(reg)
timereg.1 <- lm(Sales~d1+d2+d3+d4+Time-1, data = mydatc2t)
summary(timereg.1)
#| message: false
#| warning: false
library(tidyverse)
library(tidymodels)
# zum Plotten der Korrelationsmatrix
library(corrplot)
aq <- airquality
aq <- aq |> drop_na()
cor(aq)
corrplot(cor(aq), method = "ellipse")
#| message: false
aq %>%
ggplot() +
aes(x = Temp, y = Ozone) +
geom_point() + geom_smooth(method=lm)
# Modell initialisieren
lm_model <- linear_reg() |> set_engine("lm")
# Modell trainieren ("fitten")
lm_fit <- lm_model |> fit(Ozone ~ Temp, data = aq)
#| message: false
#| warning: false
library(tidyverse)
library(tidymodels)
# zum Plotten der Korrelationsmatrix
library(corrplot)
aq <- airquality
aq <- aq |> drop_na()
cor(aq)
corrplot(cor(aq), method = "ellipse")
#| message: false
aq %>%
ggplot() +
aes(x = Temp, y = Ozone) +
geom_point() + geom_smooth(method=lm)
# Modell initialisieren
lm_model <- linear_reg() |> set_engine("lm")
# Modell trainieren ("fitten")
lm_fit <- lm_model |> fit(Ozone ~ Temp, data = aq)
summary <- lm_fit |> extract_fit_engine() |> summary()
summary
lm_fit2 <- lm_model |> fit(Ozone ~ Temp + Solar.R, data = aq)
summary <- lm_fit2 |> extract_fit_engine() |> summary()
summary
summary2 <- lm_fit2 |> extract_fit_engine() |> summary2()
lm_fit2 <- lm_model |> fit(Ozone ~ Temp + Solar.R, data = aq)
summary2 <- lm_fit2 |> extract_fit_engine() |> summary2()
summary <- lm_fit2 |> extract_fit_engine() |> summary2()
summary <- lm_fit2 |> extract_fit_engine() |> summary()
summary
lm_fit2 <- lm_model |> fit(Ozone ~ Temp + Temp^2, data = aq)
lm_fit2 <- lm_model |> fit(Ozone ~ Temp + Solar.R, data = aq)
summary <- lm_fit2 |> extract_fit_engine() |> summary()
summary
summary <- lm_fit2 |> extract_fit_engine() |> summary()
summary
lm_fit3 <- lm_model |> fit(Ozone ~ Temp + Temp^2, data = aq)
lm_fit3 <- lm_model |> fit(Ozone ~ Temp + Temp^2, data = aq)
lm_fit3
lm_fit3 <- lm_model |> fit(Ozone ~ Temp + Temp**2, data = aq)
lm_fit3
lm_fit3 <- lm_model |> fit(Ozone ~ Temp + Temp**2, data = aq)
lm_fit3
lm_fit3 <- lm_model |> fit(Ozone ~ Temp + Temp**2, data = aq)
lm_fit3
lm_fit3 <- lm_model |> fit(Ozone ~ Temp + Temp**2, data = aq)
lm_fit3
summary <- lm_fit2 |> extract_fit_engine() |> summary()
summary
lm_fit2 <- lm_model |> fit(Ozone ~ Temp + Solar.R, data = aq)
lm_fit2
lm_fit3 <- lm_model |> fit(Ozone ~ Temp + I(Temp^2), data = aq)
lm_fit3
summary <- lm_fit3 |> extract_fit_engine() |> summary()
summary
predictions <- data.frame(Temp = aq$Temp, Ozone = predict(lm_fit3, newdata = aq))
predictions <- data.frame(Temp = aq$Temp, Ozone = predict(lm_fit3, new_data = aq))
# Create a scatterplot with ggplot
ggplot(aq, aes(x = Temp, y = Ozone)) +
geom_point(color = "blue", size = 3) +
geom_line(data = predictions, aes(y = Ozone), color = "red", size = 1) +
labs(title = "Observed vs. Predicted Ozone Levels",
x = "Temperature",
y = "Ozone") +
theme_minimal()
predictions <- data.frame(Temp = aq$Temp, Ozone = predict(lm_fit3, new_data = aq))
# Create a scatterplot with ggplot
ggplot(aq, aes(x = Temp, y = Ozone)) +
geom_point(color = "blue", linewidth = 3) +
geom_line(data = predictions, aes(y = Ozone), color = "red", size = 1) +
labs(title = "Observed vs. Predicted Ozone Levels",
x = "Temperature",
y = "Ozone") +
theme_minimal()
predictions <- data.frame(Temp = aq$Temp, Ozone = predict(lm_fit3, new_data = aq))
# Create a scatterplot with ggplot
ggplot(aq, aes(x = Temp, y = Ozone)) +
geom_point(color = "blue") +
geom_line(data = predictions, aes(y = Ozone), color = "red", size = 1) +
labs(title = "Observed vs. Predicted Ozone Levels",
x = "Temperature",
y = "Ozone") +
theme_minimal()
ggplot(aq, aes(x = Temp, y = Ozone)) +
geom_point(aes(color = "blue")) +
geom_line(data = predictions, aes(x = Temp, y = Ozone), color = "red", size = 1) +
labs(title = "Observed vs. Predicted Ozone Levels",
x = "Temperature",
y = "Ozone") +
theme_minimal()
predictions <- data.frame(Temp = aq$Temp, Ozone = predict(lm_fit3, new_data = aq))
ggplot(aq, aes(x = Temp, y = Ozone)) +
geom_point(aes(color = "blue")) +
geom_line(data = predictions, aes(x = Temp, y = Ozone), color = "red", size = 1) +
labs(title = "Observed vs. Predicted Ozone Levels",
x = "Temperature",
y = "Ozone") +
theme_minimal()
predictions <- data.frame(Temp = aq$Temp, Ozone = lm_fit3$fitted.values)
predictions <- data.frame(Temp = aq$Temp, Ozone = lm_fit3$fitted.values)
predictions <- data.frame(Temp = aq$Temp, Ozone = predict(lm_fit3, newdata = aq))
predictions <- data.frame(Temp = aq$Temp, Ozone = predict(lm_fit3, new_data = aq))
ggplot(aq, aes(x = Temp, y = Ozone)) +
geom_point(color = "blue") +
geom_line(data = predictions, aes(x = Temp, y = Ozone), color = "red", size = 1) +
labs(title = "Observed vs. Predicted Ozone Levels",
x = "Temperature",
y = "Ozone") +
theme_minimal()
predictions <- data.frame(Temp = aq$Temp, Ozone = predict(lm_fit3, newdata = aq))
predictions <- data.frame(Temp = aq$Temp, Ozone = predict(lm_fit3, new_data = aq))
# Create a scatterplot with ggplot
ggplot(aq, aes(x = Temp, y = Ozone)) +
geom_point(color = "blue") +
geom_line(data = predictions, aes(x = Temp, y = Ozone), color = "red", size = 1) +
labs(title = "Observed vs. Predicted Ozone Levels",
x = "Temperature",
y = "Ozone") +
theme_minimal()
library(tidyverse)
library(tidymodels)
library(randomForest)
library(tidyverse)
library(tidymodels)
library(randomForest)
library(rpart.plot)
library(dials)
data(Zoo, package="mlbench")
install.packages("mlbench")
library(tidyverse)
library(tidymodels)
library(randomForest)
library(rpart.plot)
library(dials)
data(Zoo, package="mlbench")
Zoo <- as_tibble(Zoo)
head(Zoo)
Zoo <- Zoo %>%
modify_if(is.logical, factor, levels = c(TRUE, FALSE))
head(Zoo)
summary(Zoo)
tree_mod <- decision_tree(mode = "classification",
cost_complexity = 0.1,
min_n = 10)
tree_fit_1 <- tree_mod %>%
fit(type ~ ., data = Zoo)
tree_fit_1 |>
extract_fit_engine()
tree_fit_1 |>
extract_fit_engine() |>
rpart.plot(extra = 102, roundint = FALSE)
pred <- predict(tree_fit_1, new_data = Zoo)
results1 <- Zoo %>% select(type) %>% bind_cols(pred)
accuracy(data = results1, truth = type, estimate = .pred_class)
conf_mat(data = results1, truth = type, estimate = .pred_class)
my_animal <- tibble(hair = TRUE, feathers = TRUE, eggs = FALSE,
milk = TRUE, airborne = TRUE, aquatic = FALSE, predator = TRUE,
toothed = TRUE, backbone = TRUE, breathes = TRUE, venomous = FALSE,
fins = FALSE, legs = 4, tail = TRUE, domestic = FALSE,
catsize = FALSE, type = NA)
my_animal <- my_animal %>% modify_if(is.logical, factor, levels = c(TRUE, FALSE))
my_animal
predict(tree_fit_1, new_data = my_animal)
tree_mod_of <- decision_tree(mode = "classification",
cost_complexity = 0,
min_n = 2)
tree_full <- tree_mod_of %>%
fit(type ~ ., data = Zoo)
tree_full |>
extract_fit_engine() |>
rpart.plot(extra = 2, roundint = FALSE,
box.palette = list("Gy", "Gn", "Bu", "Bn", "Or", "Rd", "Pu"))
pred <- predict(tree_full, new_data = Zoo)
results <- Zoo %>% select(type) %>% bind_cols(pred)
accuracy(data = results, truth = type, estimate = .pred_class)
set.seed(123)
Zoo_split <- initial_split(Zoo, prop = 0.8, strata = type)
Zoo_train <- training(Zoo_split)
Zoo_test  <- testing(Zoo_split)
forest_mod <- rand_forest(mtry = 3, trees = 2000) %>%
set_mode("classification")
forest_fit <- forest_mod %>%
fit(type ~ ., data = Zoo_train)
final_tree <- extract_workflow(final_fit)
final_wf <-
tree_wf %>%
finalize_workflow(best_tree)
final_fit <-
final_wf %>%
last_fit(Zoo_split)
library(tidyverse)
library(tidymodels)
library(randomForest)
library(rpart.plot)
library(dials)
data(Zoo, package="mlbench")
Zoo <- as_tibble(Zoo)
head(Zoo)
Zoo <- Zoo %>%
modify_if(is.logical, factor, levels = c(TRUE, FALSE))
head(Zoo)
summary(Zoo)
tree_mod <- decision_tree(mode = "classification",
cost_complexity = 0.1,
min_n = 10)
tree_fit_1 <- tree_mod %>%
fit(type ~ ., data = Zoo)
tree_fit_1 |>
extract_fit_engine()
tree_fit_1 |>
extract_fit_engine() |>
rpart.plot(extra = 102, roundint = FALSE)
pred <- predict(tree_fit_1, new_data = Zoo)
results1 <- Zoo %>% select(type) %>% bind_cols(pred)
accuracy(data = results1, truth = type, estimate = .pred_class)
conf_mat(data = results1, truth = type, estimate = .pred_class)
my_animal <- tibble(hair = TRUE, feathers = TRUE, eggs = FALSE,
milk = TRUE, airborne = TRUE, aquatic = FALSE, predator = TRUE,
toothed = TRUE, backbone = TRUE, breathes = TRUE, venomous = FALSE,
fins = FALSE, legs = 4, tail = TRUE, domestic = FALSE,
catsize = FALSE, type = NA)
my_animal <- my_animal %>% modify_if(is.logical, factor, levels = c(TRUE, FALSE))
my_animal
predict(tree_fit_1, new_data = my_animal)
tree_mod_of <- decision_tree(mode = "classification",
cost_complexity = 0,
min_n = 2)
tree_full <- tree_mod_of %>%
fit(type ~ ., data = Zoo)
tree_full |>
extract_fit_engine() |>
rpart.plot(extra = 2, roundint = FALSE,
box.palette = list("Gy", "Gn", "Bu", "Bn", "Or", "Rd", "Pu"))
pred <- predict(tree_full, new_data = Zoo)
results <- Zoo %>% select(type) %>% bind_cols(pred)
accuracy(data = results, truth = type, estimate = .pred_class)
set.seed(123)
Zoo_split <- initial_split(Zoo, prop = 0.8, strata = type)
Zoo_train <- training(Zoo_split)
Zoo_test  <- testing(Zoo_split)
forest_mod <- rand_forest(mtry = 3, trees = 2000) %>%
set_mode("classification")
forest_fit <- forest_mod %>%
fit(type ~ ., data = Zoo_train)
final_tree <- extract_workflow(final_fit)
final_tree <- extract_workflow(final_fit)
final_fit <-
final_wf %>%
last_fit(Zoo_split)
library(tidyverse)
library(tidymodels)
library(randomForest)
library(rpart.plot)
library(dials)
data(Zoo, package="mlbench")
Zoo <- as_tibble(Zoo)
head(Zoo)
Zoo <- Zoo %>%
modify_if(is.logical, factor, levels = c(TRUE, FALSE))
head(Zoo)
summary(Zoo)
tree_mod <- decision_tree(mode = "classification",
cost_complexity = 0.1,
min_n = 10)
tree_fit_1 <- tree_mod %>%
fit(type ~ ., data = Zoo)
tree_fit_1 |>
extract_fit_engine()
tree_fit_1 |>
extract_fit_engine() |>
rpart.plot(extra = 102, roundint = FALSE)
pred <- predict(tree_fit_1, new_data = Zoo)
results1 <- Zoo %>% select(type) %>% bind_cols(pred)
accuracy(data = results1, truth = type, estimate = .pred_class)
conf_mat(data = results1, truth = type, estimate = .pred_class)
my_animal <- tibble(hair = TRUE, feathers = TRUE, eggs = FALSE,
milk = TRUE, airborne = TRUE, aquatic = FALSE, predator = TRUE,
toothed = TRUE, backbone = TRUE, breathes = TRUE, venomous = FALSE,
fins = FALSE, legs = 4, tail = TRUE, domestic = FALSE,
catsize = FALSE, type = NA)
my_animal <- my_animal %>% modify_if(is.logical, factor, levels = c(TRUE, FALSE))
my_animal
predict(tree_fit_1, new_data = my_animal)
tree_mod_of <- decision_tree(mode = "classification",
cost_complexity = 0,
min_n = 2)
tree_full <- tree_mod_of %>%
fit(type ~ ., data = Zoo)
tree_full |>
extract_fit_engine() |>
rpart.plot(extra = 2, roundint = FALSE,
box.palette = list("Gy", "Gn", "Bu", "Bn", "Or", "Rd", "Pu"))
pred <- predict(tree_full, new_data = Zoo)
results <- Zoo %>% select(type) %>% bind_cols(pred)
accuracy(data = results, truth = type, estimate = .pred_class)
set.seed(123)
Zoo_split <- initial_split(Zoo, prop = 0.8, strata = type)
Zoo_train <- training(Zoo_split)
Zoo_test  <- testing(Zoo_split)
forest_mod <- rand_forest(mtry = 3, trees = 2000) %>%
set_mode("classification")
forest_fit <- forest_mod %>%
fit(type ~ ., data = Zoo_train)
install.packages("ranger")
library(tidyverse)
library(tidymodels)
library(randomForest)
library(rpart.plot)
library(dials)
data(Zoo, package="mlbench")
Zoo <- as_tibble(Zoo)
head(Zoo)
Zoo <- Zoo %>%
modify_if(is.logical, factor, levels = c(TRUE, FALSE))
head(Zoo)
summary(Zoo)
tree_mod <- decision_tree(mode = "classification",
cost_complexity = 0.1,
min_n = 10)
tree_fit_1 <- tree_mod %>%
fit(type ~ ., data = Zoo)
tree_fit_1 |>
extract_fit_engine()
tree_fit_1 |>
extract_fit_engine() |>
rpart.plot(extra = 102, roundint = FALSE)
pred <- predict(tree_fit_1, new_data = Zoo)
results1 <- Zoo %>% select(type) %>% bind_cols(pred)
accuracy(data = results1, truth = type, estimate = .pred_class)
conf_mat(data = results1, truth = type, estimate = .pred_class)
my_animal <- tibble(hair = TRUE, feathers = TRUE, eggs = FALSE,
milk = TRUE, airborne = TRUE, aquatic = FALSE, predator = TRUE,
toothed = TRUE, backbone = TRUE, breathes = TRUE, venomous = FALSE,
fins = FALSE, legs = 4, tail = TRUE, domestic = FALSE,
catsize = FALSE, type = NA)
my_animal <- my_animal %>% modify_if(is.logical, factor, levels = c(TRUE, FALSE))
my_animal
predict(tree_fit_1, new_data = my_animal)
tree_mod_of <- decision_tree(mode = "classification",
cost_complexity = 0,
min_n = 2)
tree_full <- tree_mod_of %>%
fit(type ~ ., data = Zoo)
tree_full |>
extract_fit_engine() |>
rpart.plot(extra = 2, roundint = FALSE,
box.palette = list("Gy", "Gn", "Bu", "Bn", "Or", "Rd", "Pu"))
pred <- predict(tree_full, new_data = Zoo)
results <- Zoo %>% select(type) %>% bind_cols(pred)
accuracy(data = results, truth = type, estimate = .pred_class)
set.seed(123)
Zoo_split <- initial_split(Zoo, prop = 0.8, strata = type)
Zoo_train <- training(Zoo_split)
Zoo_test  <- testing(Zoo_split)
forest_mod <- rand_forest(mtry = 3, trees = 2000) %>%
set_mode("classification")
forest_fit <- forest_mod %>%
fit(type ~ ., data = Zoo_train)
pred <- predict(forest_fit, new_data = Zoo_train)
results <- Zoo_train %>% select(type) %>% bind_cols(pred)
accuracy(data = results, truth = type, estimate = .pred_class)
pred <- predict(forest_fit, new_data = Zoo_test)
results <- Zoo_test %>% select(type) %>% bind_cols(pred)
accuracy(data = results, truth = type, estimate = .pred_class)
tune_spec <-
decision_tree(
cost_complexity = tune(),
min_n = tune()
) %>%
set_engine("rpart") %>%
set_mode("classification")
tree_grid <- grid_regular(cost_complexity(),
min_n(),
levels = 5)
tree_grid
set.seed(234)
Zoo_folds <- vfold_cv(Zoo_train)
Zoo_folds
set.seed(345)
tree_wf <- workflow() %>%
add_model(tune_spec) %>%
add_formula(type ~ .)
tree_res <-
tree_wf %>%
tune_grid(
resamples = Zoo_folds,
grid = tree_grid
)
tree_res
tree_res %>%
collect_metrics()
tree_res %>%
show_best("accuracy")
best_tree <- tree_res %>%
select_best("accuracy")
best_tree
final_wf <-
tree_wf %>%
finalize_workflow(best_tree)
final_wf
final_fit <-
final_wf %>%
last_fit(Zoo_split)
final_fit |> collect_metrics()
final_tree <- extract_workflow(final_fit)
final_tree %>%
extract_fit_engine() %>%
rpart.plot(extra = 102,
roundint = FALSE,
box.palette = list("Gy", "Gn", "Bu", "Bn", "Or", "Rd", "Pu"))
