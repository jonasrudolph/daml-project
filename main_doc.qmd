---
title: "Prüfungsleistung Data Science & Machine Learning: Salary by job title and country"
title-block-banner: true
author: Mathis, Julia und Jonas
format: 
  html: 
    theme: Superhero
    toc: true
    toc_float: true
    embed-resources: true
    code-fold: true
  pdf: 
    toc: true
    number-sections: true
date: 2023-11-13
---

# Vorbereitung

## Importieren der benötigten Packages

```{r}
library(tidyverse)
library(explore) 
library(ggplot2)
library(corrplot)
```

## Einlesen der zu Analysierenden Daten

Der Datensatz, der in diesem Projekt analysiert wird, stammt von der website "Kaggle" und beschreibt das Gehalt nach Job und Land in dem gearbeitet wird.

```{r}
salary <- read_csv("Salary.csv")
```

## Erster Überblick der Daten

Um einen ersten Überblick zu erhalten, werden die ersten 10 Zeilen der Tabelle ausgelesen:

```{r}
head(salary, 10)
```

Mithilfe der "describe_tbl"- Funktion können die generellen Informationen über den Datensatz ermittelt werden.

```{r}
describe_tbl(salary)
```

Wie oben zu erkennen, enthält der Datensatz 6684 Instanzen, wovon keine einen Wert ohne Angabe (NA's) besitzt.

Nun wird ein kurzer Blick auf die Art der Merkmale geholfen. Gibt es kategorische oder nummerische Merkmale innerhalb des Datensatzes?

```{r}
describe(salary)
```

| Spalte              | Typ         | Bedeutung                     |
|---------------------|-------------|-------------------------------|
| Age                 | Numerisch   | Alter                         |
| Gender              | Kategorisch | Geschlecht                    |
| Education Level     | Numerisch   | Bildungsgrad                  |
| Job Title           | Kategorisch | Jobtitel                      |
| Years of Experience | Numerisch   | Arbeitserfahrung in Jahren    |
| Salary              | Numerisch   | Gehalt                        |
| Country             | Kategorisch | Land                          |
| Race                | Kategorisch | Ethnizität                    |
| Senior              | Numerisch   | Senior position ja(1)/nein(0) |

: Wie bereits oben in der Tabelle zu erkennen gibt es Innerhalb des Datensatzes nur zwei verschiedene Datentypen. Die Felder \*Age, Education Level, Years of Experience, Salary, Senior\* sind nummerische Merkmale. Die Felder *Gender, Job Title, Country, Race* sind kategorische Merkmale.

## Daten verstehen

Im folgenden Abschnitt werden verschiedene Funktionen dafür verwendet, um die Datentypen und Bedeutung der Spalten zu verstehen.

```{r}
salary <- salary |>
    rename(
      Job.Title = `Job Title`,
      Years.Of.Experience = `Years of Experience`,
      Education.Level = `Education Level`
    )
```

Hier werden die Spaltennamen der Spalten verändert, welche ein Leerzeichen im Namen haben. Es handelt sich hierbei um die Spalten "Job Title", "Years of Experience" und "Education level". Das Leerzeichen wird einfach durch einen Punkt ersetzt. Da noch häufig im Laufe des Projektes auf die Spaltennamen zugegriffen werdne muss, wird Uns das in der Zukunft noch Zeit sparen.

Nun werfen verschaffen Wir uns einen Überblick über die prozentuale Verteilung der Jobtitel. Aus der Grafik geht hervor, dass der Beruf des "Data Scientist" der meist ausgeführte Beruf ist. Außerdem gibt es innerhalb des Datensatzes auch viele "Data Analsysten" , sowie auch "Backend Devolper".

```{r}
explore (salary, Job.Title)
```

### Grundlegende Statistische Merkmale des Datensatzes

Im folgenden wird ein Überblick über die grundlegenden statistischen Merkmale geworfen:

```{r}
summary(salary)
```

Erkennbar hier ist es, dass es innerhalb des Datensatzes ein durchschnittliches Alter von 32 Jahren vorliegt. Das Alter streckt sich von 21 Jahren bis zu 62 Jahren. Außerdem gibt es beim "Education-Level" Werte zwischen 1, 2 und 3, wobei der Durchschnitt jedoch bei 1 liegt. Außerdem gibt es bei der Berufserfahrung ( Years of Experience) Werte zwischen 0 bis zu 34 Jahren. Der Median hier beträgt 7.

#### Umstrukturierung des Datensatzes

Im folgenden wird der Datensatz umstrukturiert und ein neuer Wert Namens "Value" wird erschaffen. Dies geschieht um möglicherweise besser analysieren und visualisieren zu können.

```{r}
Salary_long <- select(salary, -Job.Title, -Gender, -Race, -Country, -Senior)
Salary_long <- pivot_longer(Salary_long, colnames(Salary_long))
Salary <- as.data.frame(Salary_long) 
head(Salary_long)
```

Insgesamt werden in diesem Codechunk die Spalten die nicht nummerische Merkmale sind entfernt und der verbleibende Datensatz wird von einem breiten in ein längeres Format umgewandelt.

```{r}
ggplot(Salary_long, aes(x = value)) +
  geom_histogram() +
  facet_wrap(~ name, scales = "free")
```

Hier kann man folgende Dinge erkennen:

-   Age, Years of Experience und Education Level sind Linksschief und haben ggf. Bedarf einer Transformation für ML-Modelle

-   Age und Years of Experience haben Extrempunkte im oberen Wertebereich, während Salary einer gleichmäßigen Verteilung folgt

Aufgrund der guten Strukturiertheit der Daten eignen sie sich dem ersten Anschein nach gut für eine Ausführliche Explorative Analyse.

## Datenaufbereitung

### Erstellung des entgültigen Datensets

Zunächst werden die Daten aus dem Ausgangsdatensatz in einen finalen Datensatz "salary_final" geschrieben.

```{r}
salary_final <- salary
```

Durch den Befehl "hist()" wird ein Histogramm erstellt . Es ermöglicht eine visuelle Darstellung der Häufigkeitsverteilung dieses GEhlatsdaten, indem es zeigt, wie oft bestimmte Gehaltsbereiche vorkommen.

```{r}
hist(salary_final$Salary)
```

Im folgenden wird eine neue Spalte "SalaryKat" erstellt die kategorische Werte basdierend auf den Gehältern enthält..........

```{r}

salary_final$SalaryKat <- cut(salary_final$Salary, 
                  breaks = c(-Inf, 50000, 100000, 150000, 200000, 250000, Inf),                      labels = c("50000", "100000", "150000", "200000","250000", "300000"))

```

........

```{r}
explore(salary_final, SalaryKat)
```

# Tets

im folgenden werden anhand der Daten ein paar Tests durchgeführt. Das Ergebnis dieses Codechunks ist eine Darstellung der Korrelationsmatrix.

```{r}
correlations <- cor(salary_final[, c("Age", "Education.Level", "Years.Of.Experience", "Salary")])

print(correlations)
```

Erkennbar hier ist es zum Beispiel eine starke Korrelation zwischen dem Alter und den "Years of Experience". Desweiteren liegt auch eine starke Korrelation zwischnem den Years of Experience und dem entgültigen Gehalt. Eine nichgt so starke Korrelation liegt zwischen dem Alter und dem Education Level mit einem Wert von ungefähr 0,6.

```{r}
ggplot(salary_final, aes(x = Years.Of.Experience, y = Salary)) +
  geom_point(color = "blue", size = 3, shape = 16) +
  labs(title = "Scatter Plot of Years of Experience vs Salary",
       x = "Years of Experience",
       y = "Salary")
```

```{r}
ggplot(salary_final, aes(x = Education.Level, y = Salary)) +
  geom_point(color = "blue", size = 3, shape = 16) +
  labs(title = "Scatter Plot of Years of Experience vs Salary",
       x = "Years of Experience",
       y = "Salary")

```

```{r}
ggplot(salary_final, aes(x = Race, y = Salary)) +
  geom_bar(stat = "summary", fun = "mean", fill = "blue") +
  labs(title = "Average Salary by Race",
       x = "Race",
       y = "Average Salary")

```

```{r}
ggplot(salary_final, aes(x = Gender, y = Salary, fill = Gender)) +
  geom_boxplot() +
  labs(title = "Distribution of Salary by Gender",
       x = "Gender",
       y = "Salary")
```

```{r}
ggplot(salary_final, aes(x = Country, y = Salary, fill = Country)) +
  geom_bar(stat = "summary", fun = "mean", position = "dodge", color = "black") +
  labs(title = "Average Salary by Country",
       x = "Country",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}



ggplot(salary_final, aes(x = Country, y = Salary, fill = Gender)) +
  geom_bar(stat = "summary", fun = "mean", position = "stack", color = "black") +
  labs(title = "Average Salary by Country and Gender",
       x = "Country",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

```

```{r}
ggplot(salary_final, aes(x = Country, y = Salary, fill = factor(Education.Level))) +
  geom_bar(stat = "summary", fun = "mean", position = "dodge", color = "black") +
  labs(title = "Average Salary by Country and Education Level",
       x = "Country",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  
```

```{r}
ggplot(salary_final, aes(x = Country, y = Salary, fill = Race)) +
  geom_bar(stat = "summary", fun = "mean", position = "stack", color = "black") +
  labs(title = "Average Salary by Country and Race",
       x = "Country",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

```{r}
ggplot(salary_final, aes(x = Country, y = Salary, fill = Race)) +
  geom_boxplot() +
  stat_summary(fun = "median", geom = "point", shape = 18, size = 3, color = "red", position = position_dodge(width = 0.75)) +
  labs(title = "Salary Distribution by Country and Race",
       x = "Country",
       y = "Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  

```

```{r}
ggplot(salary_final, aes(x = Job.Title, y = Salary)) +
  geom_bar(stat = "summary", fun = "mean", fill = "blue", color = "black") +
  labs(title = "Average Salary by Job Title",
       x = "Job Title",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  
```

```{r}
job_title_count <- table(salary_final$Job.Title)
print(job_title_count)
```

```{r}
job_title_count <- table(salary_final$Job.Title)
job_title_df <- data.frame(Job_Title = names(job_title_count), Frequency = as.numeric(job_title_count))

ggplot(job_title_df, aes(x = Job_Title, y = Frequency)) +
  geom_bar(stat = "identity", fill = "blue", color = "black") +
  labs(title = "Frequency of Unique Job Titles",
       x = "Job Titles",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  
```

Da in dem Datensatz teilweise Jobs nur einmalig vertreten sind, kann ein erhebliches Stichproben-Bias verursacht werden. Da das mittlere Einkommen ein wichtiges Merkmal in unserer explorativen Datenanalyse darstellt und mindestens 30 Einträge für eine aussagekräftige Stichprobe nötig sind, haben wir uns dazu entschlossen alle Einträge mit N\<30 bei der Anzahl der Jobtitel (N) abzuschneiden.

```{r}
filtered_data <- salary_final %>%
  group_by(Job.Title) %>%
  summarise(job_count = n()) %>%
  filter(job_count > 30) %>%
  inner_join(salary_final, by = "Job.Title")

print(filtered_data)
```

```{r}
job_title_count <- table(filtered_data$Job.Title)
print(job_title_count)
```

```{r}
job_title_count <- table(filtered_data$Job.Title)
job_title_df <- data.frame(Job_Title = names(job_title_count), Frequency = as.numeric(job_title_count))

ggplot(job_title_df, aes(x = Job_Title, y = Frequency)) +
  geom_bar(stat = "identity", fill = "blue", color = "black") +
  labs(title = "Frequency of Unique Job Titles",
       x = "Job Titles",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  
```

```{r}
job_title_count_filtered <- table(filtered_data$Job.Title)
cat(paste(names(job_title_count_filtered), ":", job_title_count_filtered, "\n"))
```

```{r}
filtered_data_numeric <- select(salary, Salary, Age, Years.Of.Experience, Education.Level)
glimpse(filtered_data_numeric)
cor(filtered_data_numeric)
```

```{r}
filtered_data_numeric |>
   cor() |> 
   corrplot(method = 'ellipse')
```

anzahl der technischen und adminsitrativen berufe

```{r}

# Filtern nach technischen Jobs
technische_jobs <- filtered_data[grep("data|engineer|developer|analyst|scientist", tolower(filtered_data$Job.Title)), ]

# Filtern nach wirtschaftlichen/administrativen Jobs
admin_jobs <- filtered_data[grep("associate|director|manager|sales|coordinator|generalist", tolower(filtered_data$Job.Title)), ]

# Beispiel für die Ausgabe der ersten paar Zeilen der gefilterten Daten
head(technische_jobs)
head(admin_jobs)

```

```{r}

# Anzahl der technischen Jobs
anzahl_technische_jobs <- nrow(technische_jobs)
cat("Anzahl der technischen Jobs:", anzahl_technische_jobs, "\n")

# Anzahl der administrativen Jobs
anzahl_admin_jobs <- nrow(admin_jobs)
cat("Anzahl der administrativen Jobs:", anzahl_admin_jobs, "\n")

```

```{r}

# Anzahl der Zeilen (Werte) in filtered_data
anzahl_werte_filtered_data <- nrow(filtered_data)

# Anzeigen der Anzahl der Werte
cat("Anzahl der Werte in filtered_data:", anzahl_werte_filtered_data, "\n")

```

```{r}
anzahl_jobs <- anzahl_technische_jobs + anzahl_admin_jobs
cat(anzahl_jobs)
```

problem da jobs anscheinend doppelt gezählt werden ich glaube wir müssen den jobs eine id geben

```{r}


# Add ID-Spalte
filtered_data$ID <- 1:nrow(filtered_data)

# Filtern nach technischen Jobs und Entfernen von Duplikaten
technische_jobs2 <- unique(filtered_data[grep("data|engineer|developer|analyst|scientist", tolower(filtered_data$Job.Title)), ])

# Filtern nach wirtschaftlichen/administrativen Jobs und Entfernen von Duplikaten
admin_jobs2 <- unique(filtered_data[grep("associate|director|manager|sales|coordinator|generalist", tolower(filtered_data$Job.Title)), ])

# Merke die IDs der übereinstimmenden Zeilen
ids_technische_jobs <- filtered_data$ID[filtered_data$Job.Title %in% technische_jobs2$Job.Title]
ids_admin_jobs <- filtered_data$ID[filtered_data$Job.Title %in% admin_jobs2$Job.Title]

# Entferne die entsprechenden Zeilen aus filtered_data
filtered_data_neu <- filtered_data[!(filtered_data$ID %in% c(ids_technische_jobs, ids_admin_jobs)), ]

# Beispiel für die Ausgabe der ersten paar Zeilen der gefilterten Daten
head(filtered_data_neu)

```

```{r}
anzahl_technische_jobs2 <- nrow(technische_jobs2)
cat("Anzahl der technischen Jobs2:", anzahl_technische_jobs2, "\n")

anzahl_admin_jobs2 <- nrow(admin_jobs2)
cat("Anzahl der administrativen Jobs2:", anzahl_admin_jobs2, "\n")
```

```{r}

```

basieren auf filtered_data ein neues dataset erstellt wird aus dem ein datensatz gelöscht wird sobald eine zeile einer der \_jobs table zugewiesen wird damit es nicht doppelt gezählt werden kann

-   Männer haben im Durchschnitt mehr Yrs of Experience als Frauen -\> Lässt sich die Genderpaygap auf die Yrs of Exp übertragen?

```{r}
ggplot(filtered_data, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()

```

```{r}
# Bibliothek ggplot2 laden
library(ggplot2)

# Daten für China filtern
data_china <- subset(filtered_data, Country == "China")

# Boxplot erstellen
ggplot(data_china, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender (China)",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()

```

```{r}
# Bibliothek ggplot2 laden
library(ggplot2)

# Daten für China filtern
data_china <- subset(filtered_data, Country == "China")

# Boxplot für Salary vs. Gender erstellen
ggplot(data_china, aes(x = factor(Gender), y = Salary, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Salary vs. Gender (China)",
       x = "Gender",
       y = "Salary",
       fill = "Gender") +
  theme_minimal()

```

```{r}
# Bibliothek ggplot2 laden
library(ggplot2)

# Daten für USA filtern
data_usa <- subset(filtered_data, Country == "USA")

# Boxplot erstellen
ggplot(data_usa, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender (USA)",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()

```

```{r}
# Bibliothek ggplot2 laden
library(ggplot2)

# Daten für USA filtern
data_usa <- subset(filtered_data, Country == "USA")

# Boxplot für Salary vs. Gender erstellen
ggplot(data_usa, aes(x = factor(Gender), y = Salary, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Salary vs. Gender (USA)",
       x = "Gender",
       y = "Salary",
       fill = "Gender") +
  theme_minimal()

```

ist jetzt der gender pay gap in china doch größer da der größte faktor für salary years of experience ist?

```{r}
# Korrelation zwischen Salary und Years.Of.Experience berechnen
correlation_salary_experience <- cor(filtered_data$Salary, filtered_data$Years.Of.Experience)

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Salary und Years.Of.Experience ist:", correlation_salary_experience, "\n")
```

```{r}
# Korrelation zwischen Salary und Education.Level berechnen
correlation_salary_education <- cor(filtered_data$Salary, filtered_data$Education.Level, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Salary und Education.Level ist:", correlation_salary_education, "\n")

```

```{r}
# Korrelation zwischen Salary und Age berechnen
correlation_salary_age <- cor(filtered_data$Salary, filtered_data$Age, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Salary und Age ist:", correlation_salary_age, "\n")
```

```{r}
# Korrelation zwischen Years.Of.Experience und Age berechnen
correlation_experience_age <- cor(filtered_data$Years.Of.Experience, filtered_data$Age, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Years.Of.Experience und Age ist:", correlation_experience_age, "\n")

```

das ergebnis der correlationen: von salary und years.of.experience ist es 0.81 von Salary und Age ist es 0.73 und die von Age und Years.Of.Experience ist 0.93 wie kommt so ein starker unterschied zu stande bei den werten im vergleich zu salary obwohl sie doch eine hohe correlation zueinander haben

Verteilung der Daten: Es ist möglich, dass die Verteilung der Daten in den Variablen "Age" und "Years.Of.Experience" anders ist als in der Variable "Salary". Wenn die Daten in "Age" und "Years.Of.Experience" breiter gestreut sind, kann dies zu einer geringeren Korrelation führen, selbst wenn eine starke lineare Beziehung besteht.

Nicht-lineare Beziehung: Die Korrelation misst nur lineare Beziehungen. Wenn die Beziehung zwischen "Age" und "Years.Of.Experience" nicht linear ist, könnte dies zu einem niedrigeren Korrelationswert führen.

Ausreißer: Das Vorhandensein von Ausreißern kann die Korrelation beeinflussen. Wenn es Ausreißer in einer der Variablen gibt, kann dies den Korrelationswert beeinträchtigen.

Stichprobengröße: Bei kleineren Stichproben können Korrelationswerte instabiler sein.

```{r}
# Durchschnittliche Gehälter pro Jobtyp für technische_jobs2 berechnen
average_salaries_technical <- mean(technische_jobs2$Salary)

# Durchschnittliche Gehälter pro Jobtyp für admin_jobs2 berechnen
average_salaries_admin <- mean(admin_jobs2$Salary)

# Daten zusammenführen
all_average_salaries <- data.frame(Job.Type = c("technisch", "admin"),
                                   Average.Salary = c(average_salaries_technical, average_salaries_admin))

# Diagramm erstellen
ggplot(all_average_salaries, aes(x = Job.Type, y = Average.Salary, fill = Job.Type)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.7) +
  labs(title = "Durchschnittliche Gehälter nach Jobtyp",
       x = "Jobtyp",
       y = "Durchschnittliches Gehalt") +
  theme_minimal()
```

Und das Obwohl in den Admin Jobs auch direktoren und Manager vertreten sind

Nehmen wir an das Manager ein Job Titel wie Projekt Manager ist und nicht Manager für Projekt Management und dieser Titel in unserem Datensatz Director ist? Thema Führungsposition

# Ohne Witz ich bin Dumm wie Brot. Das Problem mit der Klassifiierung der Jobs nach Technisch und Administrativ lässt sich lösen in dem ich die nicht in 2 tabellen aufteile sondern sie klassifiziere...

Vielleicht einen Anderen Datensatz hinzuziehen um Länder als "Aufgeklärt" zu bewerten

```{r}
# Beispiel-Datensatz erstellen (ersetzen Sie dies durch Ihren tatsächlichen Datensatz)
set.seed(42)
technische_jobs <- data.frame(
  Race = sample(c("White", "Black", "Asian", "Other"), 100, replace = TRUE)
)

# Diagramm erstellen
ggplot(technische_jobs, aes(x = Race, fill = Race)) +
  geom_bar() +
  labs(title = "Verteilung der Race in technische_jobs",
       x = "Race",
       y = "Anzahl") +
  theme_minimal()

```

```{r}
# Annahme: "filtered_data" ist Ihr Datensatz
# Annahme: Die Spalten sind "Seniority" und "Years.Of.Experience"

# Korrelation zwischen Seniority und Years.Of.Experience berechnen
correlation_seniority_experience <- cor(filtered_data$Senior, filtered_data$Years.Of.Experience, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Seniority und Years.Of.Experience ist:", correlation_seniority_experience, "\n")

```

## Datenaufbereitung 2

Unsere Untersuchungen haben Ergeben das wir die Daten für unsere Explorative Datenanalyse aber auch die Regression neu aufbereiten müssen.

Dazu suchen wir: unterscheide ich einen native und expat im jeweiligen Land. Welche annahmen sind dafür nötig? Hier die annahme das White generell nicht ausgewandert ist da wir hier länder mit ähnlicher kultur und salary haben

```{r}
ggplot(filtered_data, aes(x = Country, fill = Race)) +
  geom_bar(position = "dodge") +
  labs(title = "Count of Races in Each Country",
       x = "Country",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Dafür füge ich eine neue spalte ein die mit numerishcen werten arbeitet. 0 steht für einheimischer und 1 für expat. Den wert null erhalten alle zeilen bei denen wir folgende übereinstimmung feststllen (land und ethnizität hier country und race):
African American (USA)
White (Canada, USA, UK, Australia)
Chinese (China)
Australian(Australia)
Welsh (UK)
jede andere race ist ja dementsprechend expat und erhält eine 1 in der spalte expat

```{r}
# Erstellen der Spalte "Expat" basierend auf den angegebenen Kriterien
filtered_data$Expat <- 0  # Standardwert 0 (Einheimische)

# Festlegen von Bedingungen für Expats basierend auf Land und Ethnizität
expat_conditions <- list(
  filtered_data$Race == "African American" & filtered_data$Country == "USA",
  filtered_data$Race %in% c("White", "Chinese", "Australian", "Welsh") &
    filtered_data$Country %in% c("Canada", "USA", "UK", "Australia"),
  TRUE  # Für alle anderen Rassen (Expat)
)

# Setzen von Werten entsprechend den Bedingungen
filtered_data$Expat <- ifelse(expat_conditions[[1]] | expat_conditions[[2]], 0, 
                               ifelse(expat_conditions[[3]], 1, NA))

# Anzeige des aktualisierten Datensatzes zur Überprüfung
head(filtered_data)

```

```{r}
# Erstellung des Boxplots für Expats und Einheimische
ggplot(filtered_data, aes(x = as.factor(Expat), y = Salary, fill = factor(Expat))) +
  geom_boxplot() +
  labs(title = "Vergleich der Gehälter von Expats und Einheimischen",
       x = "Expat",
       y = "Gehalt") +
  scale_x_discrete(labels = c("Einheimische (0)", "Expats (1)")) +
  theme_minimal()

```

```{r}
# Mittelwert der Gehälter für Expats (Expat = 1)
mean_salary_expat <- mean(filtered_data$Salary[filtered_data$Expat == 1], na.rm = TRUE)
mean_salary_expat

# Mittelwert der Gehälter für Einheimische (Expat = 0)
mean_salary_native <- mean(filtered_data$Salary[filtered_data$Expat == 0], na.rm = TRUE)
mean_salary_native

```

These verworfen.
