---
title: "Prüfungsleistung Data Science & Machine Learning: Salary by job title and country"
title-block-banner: true
author: Mathis, Julia und Jonas
format: 
  html: 
    theme: Superhero
    toc: true
    toc_float: true
    embed-resources: true
    code-fold: true
  pdf: 
    toc: true
    number-sections: true
date: 2023-11-13
---

# 1. Vorbereitung

Im folgenden Teil dieser Arbeit werden die Vorbereitungen getroffen, die notwendig sind um die Durchführung des Projekts zu ermöglichen.

## 1.1 Importieren der benötigten Packages

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(explore) 
library(ggplot2)
library(corrplot)
library(dplyr)
```

Häufig kommt:\
WARNING: Rtools is required to build R packages but is not currently installed. Please download and install the appropriate version of Rtools before proceeding: https://cran.rstudio.com/bin/windows/Rtools/ Warning in install.packages : Paket \'dplyr\' wird gerade benutzt und deshab nicht installiert

Installiere RTools nach Link:
https://cran.rstudio.com/bin/windows/Rtools/rtools43/rtools.html

## 1.2 Einlesen der zu Analysierenden Daten

Der Datensatz, der in diesem Projekt analysiert wird, stammt von der website "Kaggle" und beschreibt das Gehalt nach Job und Land in dem gearbeitet wird.

```{r}
salary <- read_csv("Salary.csv")
```

# 2. Erster Überblick der Daten

Um einen ersten Überblick zu erhalten, werden die ersten 10 Zeilen der Tabelle ausgelesen:

```{r}
head(salary, 10)
```

Mithilfe der "describe_tbl"- Funktion können die generellen Informationen über den Datensatz ermittelt werden.

```{r}
describe_tbl(salary)
```

Wie oben zu erkennen, enthält der Datensatz 6684 Instanzen, wovon keine einen Wert ohne Angabe (NA's) besitzt.

Nun wird ein kurzer Blick auf die Art der Merkmale geholfen. Gibt es kategorische oder nummerische Merkmale innerhalb des Datensatzes?

```{r}
describe(salary)
```

| Spalte              | Typ         | Bedeutung                     |
|---------------------|-------------|-------------------------------|
| Age                 | Numerisch   | Alter                         |
| Gender              | Kategorisch | Geschlecht                    |
| Education Level     | Numerisch   | Bildungsgrad                  |
| Job Title           | Kategorisch | Jobtitel                      |
| Years of Experience | Numerisch   | Arbeitserfahrung in Jahren    |
| Salary              | Numerisch   | Gehalt                        |
| Country             | Kategorisch | Land                          |
| Race                | Kategorisch | Ethnizität                    |
| Senior              | Numerisch   | Senior position ja(1)/nein(0) |

: Wie bereits oben in der Tabelle zu erkennen gibt es Innerhalb des Datensatzes nur zwei verschiedene Datentypen. Die Felder \*Age, Education Level, Years of Experience, Salary, Senior\* sind nummerische Merkmale. Die Felder *Gender, Job Title, Country, Race* sind kategorische Merkmale.

## 2.1 Bedeutung von Spalten und Datentypen

Im folgenden Abschnitt werden verschiedene Funktionen dafür verwendet, um die Datentypen und Bedeutung der Spalten zu verstehen.

```{r}
salary <- salary |>
    rename(
      Job.Title = `Job Title`,
      Years.Of.Experience = `Years of Experience`,
      Education.Level = `Education Level`
    )
```

Hier werden die Spaltennamen der Spalten verändert, welche ein Leerzeichen im Namen haben. Es handelt sich hierbei um die Spalten "Job Title", "Years of Experience" und "Education level". Das Leerzeichen wird einfach durch einen Punkt ersetzt. Da noch häufig im Laufe des Projektes auf die Spaltennamen zugegriffen werdne muss, wird Uns das in der Zukunft noch Zeit sparen.

Nun werfen verschaffen Wir uns einen Überblick über die prozentuale Verteilung der Jobtitel. Aus der Grafik geht hervor, dass der Beruf des "Data Scientist" der meist ausgeführte Beruf ist. Außerdem gibt es innerhalb des Datensatzes auch viele "Data Analsysten" , sowie auch "Backend Devolper".

```{r}
explore (salary, Job.Title)
```

## 2.2 Grundlegende Statistische Merkmale des Datensatzes

Zunächst wird mithilfe der Funktion "summary( )" ein allgemeiner Überblick über die wichtigsten charackteristeischen Merkmale der einzelnen Splaten gegeben.

```{r}
summary(salary)
```

Erkennbar hier ist es, dass es innerhalb des Datensatzes ein durchschnittliches Alter von 32 Jahren vorliegt. Das Alter streckt sich von 21 Jahren bis zu 62 Jahren. Außerdem gibt es beim "Education-Level" Werte zwischen 1, 2 und 3, wobei der Durchschnitt jedoch bei 1 liegt. Außerdem gibt es bei der Berufserfahrung ( Years of Experience) Werte zwischen 0 bis zu 34 Jahren. Der Median hier beträgt 7.

# 3. Umstrukturierung des Datensatzes zwecks Visualisierung

Im folgenden wird der Datensatz temporär umstrukturiert um den Datensatz besser analysieren und visualieren zu können.

Ein neuer Wert Namens "Value" wird erschaffen.

```{r}
Salary_long <- select(salary, -Job.Title, -Gender, -Race, -Country, -Senior)
Salary_long <- pivot_longer(Salary_long, colnames(Salary_long))
Salary <- as.data.frame(Salary_long) 
head(Salary_long)
```

Insgesamt werden in diesem Codechunk die Spalten die nicht nummerische Merkmale sind entfernt und der verbleibende Datensatz wird von einem breiten in ein längeres Format umgewandelt.

Mithilfe des oben erstellten Wertes "Value" wird nun ein Histogramm für jede Spalte innerhalb des Datensatzes "salary_long" erstellt. Außerdem wird nach der Variable "name" gruppiert.

```{r}
ggplot(Salary_long, aes(x = value)) +
  geom_histogram() +
  facet_wrap(~ name, scales = "free")
```

Hier kann man folgende Dinge erkennen:

-   Age, Years of Experience und Education Level sind Linksschief und haben ggf. Bedarf einer Transformation für ML-Modelle

-   Age und Years of Experience haben Extrempunkte im oberen Wertebereich, während Salary einer gleichmäßigen Verteilung folgt

Aufgrund der guten Strukturierung der Daten ,eignen sie sich dem ersten Anschein nach gut für eine Ausführliche Explorative Analyse.

## 3.1 Kategorisierung von Gehalt

Zunächst werden die Daten aus dem Ausgangsdatensatz in einen finalen Datensatz "salary_final" geschrieben.

```{r}
salary_final <- salary
```

Durch den Befehl "hist()" wird ein Histogramm erstellt . Es ermöglicht eine visuelle Darstellung der Häufigkeitsverteilung dieses GEhlatsdaten, indem es zeigt, wie oft bestimmte Gehaltsbereiche vorkommen.

```{r}
hist(salary_final$Salary)
```

Im folgenden wird eine neue Spalte "SalaryKat" erstellt die kategorische Werte basdierend auf den Gehältern enthält...

```{r}

salary_final$SalaryKat <- cut(salary_final$Salary, 
                  breaks = c(-Inf, 50000, 100000, 150000, 200000, 250000, Inf),                      labels = c("50000", "100000", "150000", "200000","250000", "300000"))

```

........

```{r}
explore(salary_final, SalaryKat)
```

## 3.2 Korrelationen

Im Folgenden werden die Korrelationen zwischen den Verschiedenen Spalten errechnet.

Die Berechnung von Korrelationen ermöglicht es, die Stärke und Richtung des Zusammenhangs zwischen zwei Variablen zu quantifizieren. Dies hilft bei der Modellvalisierung, um potenzielle Probleme, wie zum Beispiel die Multikollinearität zu erkennen.

Nun werden verschiedene Korrelationen errechnet:

```{r}
# Korrelation zwischen Salary und Years.Of.Experience berechnen
correlation_salary_experience <- cor(salary_final$Salary, salary_final$Years.Of.Experience)

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Salary und Years.Of.Experience ist:", correlation_salary_experience, "\n")
```

"Hier würde Ich keinen Text vorschreiben, Ausgabe aussagekräftig genug"

```{r}
# Korrelation zwischen Salary und Age berechnen
correlation_salary_age <- cor(salary_final$Salary, salary_final$Age, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Salary und Age ist:", correlation_salary_age, "\n")
```

"Hier würde Ich keinen Text vorschreiben, Ausgabe aussagekräftig genug"

```{r}
# Korrelation zwischen Years.Of.Experience und Age berechnen
correlation_experience_age <- cor(salary_final$Years.Of.Experience, salary_final$Age, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Years.Of.Experience und Age ist:", correlation_experience_age, "\n")
```

"Hier würde Ich keinen Text vorschreiben, Ausgabe aussagekräftig genug"

```{r}
# Korrelation zwischen Seniority und Years.Of.Experience berechnen
correlation_seniority_experience <- cor(salary_final$Senior, salary_final$Years.Of.Experience, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Seniority und Years.Of.Experience ist:", correlation_seniority_experience, "\n")
```

das ergebnis der correlationen: von salary und years.of.experience ist es 0.81 von Salary und Age ist es 0.73 und die von Age und Years.Of.Experience ist 0.93 wie kommt so ein starker unterschied zu stande bei den werten im vergleich zu salary obwohl sie doch eine hohe correlation zueinander haben

Verteilung der Daten: Es ist möglich, dass die Verteilung der Daten in den Variablen "Age" und "Years.Of.Experience" anders ist als in der Variable "Salary". Wenn die Daten in "Age" und "Years.Of.Experience" breiter gestreut sind, kann dies zu einer geringeren Korrelation führen, selbst wenn eine starke lineare Beziehung besteht.

Nicht-lineare Beziehung: Die Korrelation misst nur lineare Beziehungen. Wenn die Beziehung zwischen "Age" und "Years.Of.Experience" nicht linear ist, könnte dies zu einem niedrigeren Korrelationswert führen.

Ausreißer: Das Vorhandensein von Ausreißern kann die Korrelation beeinflussen. Wenn es Ausreißer in einer der Variablen gibt, kann dies den Korrelationswert beeinträchtigen.

Stichprobengröße: Bei kleineren Stichproben können Korrelationswerte instabiler sein.

# 4. Tests für die Thesen

Im folgenden werden anhand der Daten ein paar Tests durchgeführt um Aussagen für die Thesen heruaszufiltern. Dies geschieht mithilfe einer Visualisierung der Beziehungen zwischen den verschiedenen Spalten, sowie mitihilfe von Korrelationen.

## 4.1 Korrelationen

Das Ergebnis dieses Codechunks ist eine Darstellung der Korrelationsmatrix:

```{r}
correlations <- cor(salary_final[, c("Age", "Education.Level", "Years.Of.Experience", "Salary")])

print(correlations)
```

Erkennbar hier ist eine starke Korrelation zwischen dem Alter und den "Years of Experience". Desweiteren liegt auch eine starke Korrelation zwischnem den Years of Experience und dem entgültigen Gehalt. Eine nicht so starke Korrelation liegt zwischen dem Alter und dem Education Level mit einem Wert von ungefähr 0,6.

```{r}
filtered_data_numeric <- select(salary, Salary, Age, Years.Of.Experience, Education.Level)
glimpse(filtered_data_numeric)
cor(filtered_data_numeric)
```

```{r}
filtered_data_numeric |>
cor() |>
corrplot(method = 'ellipse')
```

## 4.2 Streudiagramme

```{r}
ggplot(salary_final, aes(x = Years.Of.Experience, y = Salary)) +
  geom_point(color = "blue", size = 3, shape = 16) +
  labs(title = "Scatter Plot of Years of Experience vs Salary",
       x = "Years of Experience",
       y = "Salary")
```

In diesem Streudiagramm ist erkennbar, das es einen eindeutigen Trend nach oben gibt je mehr "Years of Experience" vorliegen. So ist auch zu sehen, dass die Topgehälter von 250.000€ zwischen 20 bis 30 Erfahrungsjahren liegen.

```{r}
ggplot(salary_final, aes(x = Education.Level, y = Salary)) +
  geom_point(color = "blue", size = 3, shape = 16) +
  labs(title = "Scatter Plot of Education Level vs Salary",
       x = "Years of Experience",
       y = "Salary")

```

Die vorliegende Datenanalyse zeigt einen klaren Trend zu höheren Gehaltsklassen, der mit einem Anstieg des Bildungsniveaus einhergeht. Diese Tendenz wird durch eine höhere Dichte in den oberen Gehaltsgruppen für Personen mit dem dritten Bildungsgrad im Vergleich zum zweiten und ersten Bildungsgrad deutlich.

## 4.3 Balkendiagramme

In diesem Abschnitt werden Balkendiagramme verwendet um den Datensatz auf Beziehungen zu analysieren.

### 4.3.1 Average Salary by Race

```{r}
ggplot(salary_final, aes(x = Race, y = Salary)) +
  geom_bar(stat = "summary", fun = "mean", fill = "blue") +
  labs(title = "Average Salary by Race",
       x = "Race",
       y = "Average Salary")

```

Die Grafik macht deutlich, dass die Gruppen "Black, Korean, Mixed und White" im Durchschnitt am meisten verdienen.

### 4.3.2 Average Salary by Country

```{r}
ggplot(salary_final, aes(x = Country, y = Salary, fill = Country)) +
  geom_bar(stat = "summary", fun = "mean", position = "dodge", color = "black") +
  labs(title = "Average Salary by Country",
       x = "Country",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Es ist ersichtlich, dass in den Ländern "Canada und China" das durchschnittliche Gehalt am größten ist. Jedochg ist zu erwähnen, dass alle Länder nah bei einander liegen.

### 4.3.3 Average Salary by Country and Gender

In diesem Fall wird ein gestapeltes Balkendiagramm erstellt. Die Balken sind nach Geschlecht gruppiert und gestapelt. DIes ermöglicht einen Vergleich der durchschnittlichen Gehälter zwischen den Ländern und Geschlechtern

```{r}
ggplot(salary_final, aes(x = Country, y = Salary, fill = Gender)) +
  geom_bar(stat = "summary", fun = "mean", position = "stack", color = "black") +
  labs(title = "Average Salary by Country and Gender",
       x = "Country",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

```

Hier ist zu erkennen, das alle Länder ungefähr die gleiche Verteilung zwischen "Male" und "Female" haben.

### 4.3.4 Average Salary by Country and Education Level

Zur Visualisierung der durchnittlichen Bezahlung für Länder und Bildungsniveau wird ein gruppiertes Balkendiagramm verwendet. DIe Balken sind nach Bildungsniveau und nebeneinander gruppiert.

Desweiteren sind zur besseren Veranschaulichung die Beschriftungen auf der X-Achse um 45 Grad gedreht.

```{r}
ggplot(salary_final, aes(x = Country, y = Salary, fill = factor(Education.Level))) +
  geom_bar(stat = "summary", fun = "mean", position = "dodge", color = "black") +
  labs(title = "Average Salary by Country and Education Level",
       x = "Country",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  
```

Es ist deutlich zu erkennen, dass die Gehälter in jedem Land deutlich ansteigen je höher das Bildungsniveau ist.

### 4.3.5 Average Salary by Country and Race

Auch hier wird zum Vergleich der durchschnittlichen Gehälter zwischen den Ländern und ethnischen Gruppen, ein gestapeltes Balkendiagramm erstellt. Die Balken sind nach ethnischer Gruppe gruppiert und gestapelt.

```{r}
ggplot(salary_final, aes(x = Country, y = Salary, fill = Race)) +
  geom_bar(stat = "summary", fun = "mean", position = "stack", color = "black") +
  labs(title = "Average Salary by Country and Race",
       x = "Country",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

!!!!! Salary passt nicht!!!!!!!

Hier ist deutlich sichtbar, dass nicht in jedem Land logischerweise jede ethnische Gruppe vertreten ist. So sind nur in 2 Ländern mehr als 3 verschiedene Gruppen in diesem Datensatz aufgeführt

### 4.3.6 Average Salary by Job Title

```{r}
ggplot(salary_final, aes(x = Job.Title, y = Salary)) +
  geom_bar(stat = "summary", fun = "mean", fill = "blue", color = "black") +
  labs(title = "Average Salary by Job Title",
       x = "Job Title",
       y = "Average Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  
```

Hier wird festgestellt das in dem Datensatz zu viele Jobtitle vorkommen

```{r}
job_title_count <- table(salary_final$Job.Title)
print(job_title_count)
```

Hier nochmal das obere genauer grafisch herausgearbeitet

```{r}
job_title_count <- table(salary_final$Job.Title)
job_title_df <- data.frame(Job_Title = names(job_title_count), Frequency = as.numeric(job_title_count))

ggplot(job_title_df, aes(x = Job_Title, y = Frequency)) +
  geom_bar(stat = "identity", fill = "blue", color = "black") +
  labs(title = "Frequency of Unique Job Titles",
       x = "Job Titles",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

?????

## 4.4 Boxplots

```{r}
ggplot(salary_final, aes(x = Country, y = Salary, fill = Race)) +
  geom_boxplot() +
  stat_summary(fun = "median", geom = "point", shape = 18, size = 3, color = "red", position = position_dodge(width = 0.75)) +
  labs(title = "Salary Distribution by Country and Race",
       x = "Country",
       y = "Salary") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  

```

# 5. Daten Aufbereiten

(Tests der Thesen gibt uns die Antwort darauf wie die Daten aufbereitet werden müssen)

## 5.1 Jobs

Da in dem Datensatz teilweise Jobs nur einmalig vertreten sind, kann ein erhebliches Stichproben-Bias verursacht werden. Da das mittlere Einkommen ein wichtiges Merkmal in unserer explorativen Datenanalyse darstellt und mindestens 30 Einträge für eine aussagekräftige Stichprobe nötig sind, haben wir uns dazu entschlossen alle Einträge mit N\<30 bei der Anzahl der Jobtitel (N) abzuschneiden.

```{r}
filtered_data <- salary_final %>%
  group_by(Job.Title) %>%
  summarise(job_count = n()) %>%
  filter(job_count > 30) %>%
  inner_join(salary_final, by = "Job.Title")

print(filtered_data)
```

```{r}
job_title_count <- table(filtered_data$Job.Title)
print(job_title_count)
```

```{r}
job_title_count <- table(filtered_data$Job.Title)
job_title_df <- data.frame(Job_Title = names(job_title_count), Frequency = as.numeric(job_title_count))

ggplot(job_title_df, aes(x = Job_Title, y = Frequency)) +
  geom_bar(stat = "identity", fill = "blue", color = "black") +
  labs(title = "Frequency of Unique Job Titles",
       x = "Job Titles",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  
```

Auf min 30 Jobhäufigkeiten angepasst.

```{r}
job_title_count_filtered <- table(filtered_data$Job.Title)
cat(paste(names(job_title_count_filtered), ":", job_title_count_filtered, "\n"))
```

## 5.2 Job Typen

Anzahl der technischen und adminsitrativen Berufe

```{r}

# Filtern nach technischen Jobs
technische_jobs <- filtered_data[grep("data|engineer|developer|analyst|scientist", tolower(filtered_data$Job.Title)), ]

# Filtern nach wirtschaftlichen/administrativen Jobs
admin_jobs <- filtered_data[grep("associate|director|manager|sales|coordinator|generalist|receptionist|designer", tolower(filtered_data$Job.Title)), ]

# Beispiel für die Ausgabe der ersten paar Zeilen der gefilterten Daten
head(technische_jobs)
head(admin_jobs)

```

```{r}

# Anzahl der technischen Jobs
anzahl_technische_jobs <- nrow(technische_jobs)
cat("Anzahl der technischen Jobs:", anzahl_technische_jobs, "\n")

# Anzahl der administrativen Jobs
anzahl_admin_jobs <- nrow(admin_jobs)
cat("Anzahl der administrativen Jobs:", anzahl_admin_jobs, "\n")

```

```{r}

# Anzahl der Zeilen (Werte) in filtered_data
anzahl_werte_filtered_data <- nrow(filtered_data)

# Anzeigen der Anzahl der Werte
cat("Anzahl der Werte in filtered_data:", anzahl_werte_filtered_data, "\n")

```

```{r}
anzahl_jobs <- anzahl_technische_jobs + anzahl_admin_jobs
cat(anzahl_jobs)
```

problem da jobs anscheinend doppelt gezählt werden ich glaube wir müssen den jobs eine id geben

```{r}


# Add ID-Spalte
filtered_data$ID <- 1:nrow(filtered_data)

# Filtern nach technischen Jobs und Entfernen von Duplikaten
technische_jobs2 <- unique(filtered_data[grep("data|engineer|developer|analyst|scientist", tolower(filtered_data$Job.Title)), ])

# Filtern nach wirtschaftlichen/administrativen Jobs und Entfernen von Duplikaten
admin_jobs2 <- unique(filtered_data[grep("associate|director|manager|sales|coordinator|generalist|receptionist|designer", tolower(filtered_data$Job.Title)), ])

# Merke die IDs der übereinstimmenden Zeilen
ids_technische_jobs <- filtered_data$ID[filtered_data$Job.Title %in% technische_jobs2$Job.Title]
ids_admin_jobs <- filtered_data$ID[filtered_data$Job.Title %in% admin_jobs2$Job.Title]

# Entferne die entsprechenden Zeilen aus filtered_data
filtered_data_neu <- filtered_data[!(filtered_data$ID %in% c(ids_technische_jobs, ids_admin_jobs)), ]

# Beispiel für die Ausgabe der ersten paar Zeilen der gefilterten Daten
head(filtered_data_neu)

```

```{r}
anzahl_technische_jobs2 <- nrow(technische_jobs2)
cat("Anzahl der technischen Jobs2:", anzahl_technische_jobs2, "\n")

anzahl_admin_jobs2 <- nrow(admin_jobs2)
cat("Anzahl der administrativen Jobs2:", anzahl_admin_jobs2, "\n")
```

basieren auf filtered_data ein neues dataset erstellt wird aus dem ein datensatz gelöscht wird sobald eine zeile einer der \_jobs table zugewiesen wird damit es nicht doppelt gezählt werden kann. Warum auch immer funktioniert das nicht also neuer lösungsansatz:

Das Problem mit der Klassifizierung der Jobs nach Technisch und Administrativ lässt sich lösen in dem ich die nicht in 2 tabellen aufteile sondern jeder Zeile einen Wert des Entsprechenden job types zuordne

```{r}
# Erstellung der neuen Spalte "job_type" basierend auf den gegebenen Filtern
filtered_data$job_type <- ifelse(
    grepl("data|engineer|developer|analyst|scientist", tolower(filtered_data$Job.Title)),
    0, # 0 für technische Jobs
    ifelse(
        grepl("associate|director|manager|sales|coordinator|generalist", tolower(filtered_data$Job.Title)),
        1, # 1 für administrative Jobs
        NA  # NA für alle anderen
    )
)

# Anzeige der Anzahl aller Zeilen im Datensatz und der Anzahl der Zeilen für jede job_type-Ausprägung
total_rows <- nrow(filtered_data)
count_job_types <- table(filtered_data$job_type, useNA = "ifany")

# Ausgabe der Ergebnisse
print(paste("Gesamtanzahl der Zeilen im Datensatz:", total_rows))
print("Anzahl der Zeilen für jede job_type-Ausprägung:")
print(count_job_types)

```

Auflösen der NAs

```{r}
# Auswahl aller Zeilen mit NA-Werten in der Spalte "job_type"
na_job_type_rows <- subset(filtered_data, is.na(job_type))

# Anzeige der ausgewählten Zeilen mit NA in "job_type"
na_job_type_rows

```

Das Ergebnis ist eine Table welche nur aus Product Designer & Receptionist besteht. Diese fügen wir den Administrativen Jobs hinzu.

```{r}
# Aktualisierung der job_type-Spalte für die spezifischen Job-Titel
filtered_data$job_type[filtered_data$Job.Title %in% c("Product Designer", "Receptionist")] <- 1

# Anzeige der aktualisierten Daten für die ausgewählten Job-Titel
subset(filtered_data, Job.Title %in% c("Product Designer", "Receptionist"))


# Anzeige der Anzahl aller Zeilen im Datensatz und der Anzahl der Zeilen für jede job_type-Ausprägung
total_rows <- nrow(filtered_data)
count_job_types <- table(filtered_data$job_type, useNA = "ifany")

# Ausgabe der Ergebnisse
print(paste("Gesamtanzahl der Zeilen im Datensatz:", total_rows))
print("Anzahl der Zeilen für jede job_type-Ausprägung:")
print(count_job_types)

```

Done. Im folgenden werden alle Diagramme auch über job_type ausgewertet könnnen.

## 5.3 Expats & Einheimische

```{r}
ggplot(filtered_data, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()

```

```{r}
# Bibliothek ggplot2 laden
library(ggplot2)

# Daten für China filtern
data_china <- subset(filtered_data, Country == "China")

# Boxplot erstellen
ggplot(data_china, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender (China)",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()

```

```{r}
# Bibliothek ggplot2 laden
library(ggplot2)

# Daten für China filtern
data_china <- subset(filtered_data, Country == "China")

# Boxplot für Salary vs. Gender erstellen
ggplot(data_china, aes(x = factor(Gender), y = Salary, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Salary vs. Gender (China)",
       x = "Gender",
       y = "Salary",
       fill = "Gender") +
  theme_minimal()

```

```{r}
# Bibliothek ggplot2 laden
library(ggplot2)

# Daten für USA filtern
data_usa <- subset(filtered_data, Country == "USA")

# Boxplot erstellen
ggplot(data_usa, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender (USA)",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()

```

```{r}
# Bibliothek ggplot2 laden
library(ggplot2)

# Daten für USA filtern
data_usa <- subset(filtered_data, Country == "USA")

# Boxplot für Salary vs. Gender erstellen
ggplot(data_usa, aes(x = factor(Gender), y = Salary, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Salary vs. Gender (USA)",
       x = "Gender",
       y = "Salary",
       fill = "Gender") +
  theme_minimal()

```

ist jetzt der gender pay gap in china doch größer da der größte faktor für salary years of experience ist?

```{r}
# Korrelation zwischen Salary und Years.Of.Experience berechnen
correlation_salary_experience <- cor(filtered_data$Salary, filtered_data$Years.Of.Experience)

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Salary und Years.Of.Experience ist:", correlation_salary_experience, "\n")
```

```{r}
# Korrelation zwischen Salary und Education.Level berechnen
correlation_salary_education <- cor(filtered_data$Salary, filtered_data$Education.Level, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Salary und Education.Level ist:", correlation_salary_education, "\n")

```

```{r}
# Korrelation zwischen Salary und Age berechnen
correlation_salary_age <- cor(filtered_data$Salary, filtered_data$Age, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Salary und Age ist:", correlation_salary_age, "\n")
```

```{r}
# Korrelation zwischen Years.Of.Experience und Age berechnen
correlation_experience_age <- cor(filtered_data$Years.Of.Experience, filtered_data$Age, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Years.Of.Experience und Age ist:", correlation_experience_age, "\n")

```

```{r}
# Annahme: "filtered_data" ist Ihr Datensatz
# Annahme: Die Spalten sind "Seniority" und "Years.Of.Experience"

# Korrelation zwischen Seniority und Years.Of.Experience berechnen
correlation_seniority_experience <- cor(filtered_data$Senior, filtered_data$Years.Of.Experience, use = "complete.obs")

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Seniority und Years.Of.Experience ist:", correlation_seniority_experience, "\n")

```

das ergebnis der correlationen: von salary und years.of.experience ist es 0.81 von Salary und Age ist es 0.73 und die von Age und Years.Of.Experience ist 0.93 wie kommt so ein starker unterschied zu stande bei den werten im vergleich zu salary obwohl sie doch eine hohe correlation zueinander haben

Verteilung der Daten: Es ist möglich, dass die Verteilung der Daten in den Variablen "Age" und "Years.Of.Experience" anders ist als in der Variable "Salary". Wenn die Daten in "Age" und "Years.Of.Experience" breiter gestreut sind, kann dies zu einer geringeren Korrelation führen, selbst wenn eine starke lineare Beziehung besteht.

Nicht-lineare Beziehung: Die Korrelation misst nur lineare Beziehungen. Wenn die Beziehung zwischen "Age" und "Years.Of.Experience" nicht linear ist, könnte dies zu einem niedrigeren Korrelationswert führen.

Ausreißer: Das Vorhandensein von Ausreißern kann die Korrelation beeinflussen. Wenn es Ausreißer in einer der Variablen gibt, kann dies den Korrelationswert beeinträchtigen.

Stichprobengröße: Bei kleineren Stichproben können Korrelationswerte instabiler sein.

\# Durchschnittliche Gehälter pro Jobtyp für technische_jobs2 berechnen

average_salaries_technical \<- mean(technische_jobs2\$Salary)

\# Durchschnittliche Gehälter pro Jobtyp für admin_jobs2 berechnen

average_salaries_admin \<- mean(admin_jobs2\$Salary)

\# Daten zusammenführen

all_average_salaries \<- data.frame(Job.Type = c("technisch", "admin"),

Average.Salary = c(average_salaries_technical, average_salaries_admin))

\# Diagramm erstellen

ggplot(all_average_salaries, aes(x = Job.Type, y = Average.Salary, fill = Job.Type)) +

geom_bar(stat = "identity", position = "dodge", alpha = 0.7) +

labs(title = "Durchschnittliche Gehälter nach Jobtyp",

x = "Jobtyp",

y = "Durchschnittliches Gehalt") +

theme_minimal()

```{r}
# Filtern der Daten für technische und administrative Jobs basierend auf den Kriterien
technische_jobs <- subset(filtered_data, job_type == 0)
admin_jobs <- subset(filtered_data, job_type == 1)

# Durchschnittliche Gehälter pro Jobtyp für technische Jobs berechnen
average_salaries_technical <- mean(technische_jobs$Salary, na.rm = TRUE)

# Durchschnittliche Gehälter pro Jobtyp für administrative Jobs berechnen
average_salaries_admin <- mean(admin_jobs$Salary, na.rm = TRUE)

# Zusammenführen der durchschnittlichen Gehälter in einem Datenrahmen
all_average_salaries <- data.frame(Job.Type = c("technisch", "admin"),
                                   Average.Salary = c(average_salaries_technical, average_salaries_admin))

# Erstellung des Diagramms mit angepasster Achsenbeschriftung
ggplot(all_average_salaries, aes(x = Job.Type, y = Average.Salary, fill = Job.Type)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.7) +
  labs(title = "Durchschnittliche Gehälter nach Jobtyp",
       x = "Jobtyp",
       y = "Durchschnittliches Gehalt") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma)  # Verwendung von scales::comma für die Achsenbeschriftung in Tausenden

```

Und das Obwohl in den Admin Jobs auch direktoren und Manager vertreten sind

Nehmen wir an das Manager ein Job Titel wie Projekt Manager ist und nicht Manager für Projekt Management und dieser Titel in unserem Datensatz Director ist? Thema Führungsposition

Unsere Untersuchungen haben Ergeben das wir die Daten für unsere Explorative Datenanalyse aber auch die Regression neu aufbereiten müssen.

Dazu suchen wir: unterscheide ich einen native und expat im jeweiligen Land. Welche annahmen sind dafür nötig? Hier die annahme das White generell nicht ausgewandert ist da wir hier länder mit ähnlicher kultur und salary haben

```{r}
ggplot(filtered_data, aes(x = Country, fill = Race)) +
  geom_bar(position = "dodge") +
  labs(title = "Count of Races in Each Country",
       x = "Country",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Dafür füge ich eine neue spalte ein die mit numerishcen werten arbeitet. 0 steht für einheimischer und 1 für expat. Den wert null erhalten alle zeilen bei denen wir folgende übereinstimmung feststllen (land und ethnizität hier country und race): African American (USA) White (Canada, USA, UK, Australia) Chinese (China) Australian(Australia) Welsh (UK) jede andere race ist ja dementsprechend expat und erhält eine 1 in der spalte expat

```{r}
# Erstellen der Spalte "Expat" basierend auf den angegebenen Kriterien
filtered_data$Expat <- 0  # Standardwert 0 (Einheimische)

# Festlegen von Bedingungen für Expats basierend auf Land und Ethnizität
expat_conditions <- list(
  filtered_data$Race == "African American" & filtered_data$Country == "USA",
  filtered_data$Race %in% c("White", "Chinese", "Australian", "Welsh") &
    filtered_data$Country %in% c("Canada", "USA", "UK", "Australia"),
  TRUE  # Für alle anderen Rassen (Expat)
)

# Setzen von Werten entsprechend den Bedingungen
filtered_data$Expat <- ifelse(expat_conditions[[1]] | expat_conditions[[2]], 0, 
                               ifelse(expat_conditions[[3]], 1, NA))

# Anzeige des aktualisierten Datensatzes zur Überprüfung
head(filtered_data)
```

# 6. Thesen

Aus den überlegungen der Tests haben wir folgende Thesen formuliert.

## 6.1 Genderpaygap

1.  Männer verdienen mehr als Frauen
2.  Die Differenz der Salary zwischen den Geschlechtern ist in China höher als in den westlichen Ländern.
3.  Männer haben im Durchschnitt mehr Yrs of Experience als Frauen -\> Lässt sich die Genderpaygap auf die Yrs of Exp übertragen? Und gilt dies auch für China

### 6.1.1.: Männer verdienen mehr als Frauen

```{r}
ggplot(filtered_data, aes(x = factor(Gender), y = Salary, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Salary vs. Gender",
       x = "Gender",
       y = "Salary",
       fill = "Gender") +
  theme_minimal()
```

These Korrekt

### 6.1.2.: Die Differenz der Salary zwischen den Geschlechtern ist in China höher als in den westlichen Ländern. Hier alle westlichen Länder hinzufügen

```{r}
# Daten für USA filtern
data_usa <- subset(filtered_data, Country == "USA")

# Boxplot erstellen
ggplot(data_usa, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender (USA)",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()
```

```{r}
# Daten für China filtern
data_china <- subset(filtered_data, Country == "China")

# Boxplot für Salary vs. Gender erstellen
ggplot(data_china, aes(x = factor(Gender), y = Salary, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Salary vs. Gender (China)",
       x = "Gender",
       y = "Salary",
       fill = "Gender") +
  theme_minimal()
```

These Korrekt

### 6.1.3.: Männer haben im Durchschnitt mehr Yrs of Experience als Frauen -\> Lässt sich die Genderpaygap auf die Yrs of Exp übertragen? Und gilt dies auch für China

```{r}
ggplot(filtered_data, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()
```

```{r}
# Daten für China filtern
data_china <- subset(filtered_data, Country == "China")

# Boxplot erstellen
ggplot(data_china, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender (China)",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()
```

```{r}
# Daten für USA filtern
data_usa <- subset(filtered_data, Country == "USA")

# Boxplot erstellen
ggplot(data_usa, aes(x = factor(Gender), y = Years.Of.Experience, fill = Gender)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Boxplot: Years of Experience vs. Gender (USA)",
       x = "Gender",
       y = "Years of Experience",
       fill = "Gender") +
  theme_minimal()

```

ist jetzt der gender pay gap in china doch größer da der größte faktor für salary years of experience ist?

Dafür schauen wir uns an: Korrelation von years of experience und salary

```{r}
# Korrelation zwischen Salary und Years.Of.Experience berechnen
correlation_salary_experience <- cor(filtered_data$Salary, filtered_data$Years.Of.Experience)

# Ausgabe des Ergebnisses
cat("Die Korrelation zwischen Salary und Years.Of.Experience ist:", correlation_salary_experience, "\n")
```

These Korrekt da es im gleichen Verhältnis steht. Nicht desto trotz gibt es einen Unterschied zwischen den Geschlechtern bei gleichbleibender Arbeitderfahrung was auf einen kleinen Gender Pay gap schließen lässt.

## 6.2 Expats verdienen mehr als Einheimisch

Unsere Untersuchungen haben Ergeben das wir die Daten für unsere Explorative Datenanalyse aber auch die Regression neu aufbereiten müssen.

Dazu suchen wir: unterscheide ich einen native und expat im jeweiligen Land. Welche annahmen sind dafür nötig? Hier die annahme das White generell nicht ausgewandert ist da wir hier länder mit ähnlicher kultur und salary haben

### 6.2.1.: Alle Ethnizitäten je Land

```{r}
ggplot(filtered_data, aes(x = Country, fill = Race)) +
  geom_bar(position = "dodge") +
  labs(title = "Count of Races in Each Country",
       x = "Country",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Daten für Analyse von Expats und Einheimischen bereits Aufbereitet. Bitte hier nochmal beschrieben

### 6.2.2.: Gesamtbetrachtung

```{r}
# Erstellung des Boxplots für Expats und Einheimische
ggplot(filtered_data, aes(x = as.factor(Expat), y = Salary, fill = factor(Expat))) +
  geom_boxplot() +
  labs(title = "Vergleich der Gehälter von Expats und Einheimischen",
       x = "Expat",
       y = "Gehalt") +
  scale_x_discrete(labels = c("Einheimische (0)", "Expats (1)")) +
  theme_minimal()

```

```{r}
# Mittelwert der Gehälter für Expats (Expat = 1)
mean_salary_expat <- mean(filtered_data$Salary[filtered_data$Expat == 1], na.rm = TRUE)
mean_salary_expat

# Mittelwert der Gehälter für Einheimische (Expat = 0)
mean_salary_native <- mean(filtered_data$Salary[filtered_data$Expat == 0], na.rm = TRUE)
mean_salary_native

```

These verworfen. Da es offensichtlich keine Unterschiede gibt. Ggf. noch einzelne Ethnizitäten betrachten

## 6.3 Gehaltscap education level vorhanden?

Ohne ein Mindestmaß ein Bildung ist keine weitere Gehaltsentwicklung möglich

Bildungsniveau Codes:

0 = High School Abschluss

1 = Bachelor

2 = Master

3 = Doctor

1.  **Deskriptive Statistiken:** Man könnte Quantile oder Perzentile des Gehalts für jedes Bildungsniveau berechnen. Dies bietet einen Überblick über die Verteilung der Gehälter und zeigt potenzielle Grenzwerte auf.

2.  **Boxplots pro Bildungsniveau:** Man könnte Boxplots für jedes Bildungsniveau erstellen, um die Verteilung der Gehälter visuell zu vergleichen. Dies kann helfen, Ausreißer und Unterschiede zwischen den Bildungsniveaus zu identifizieren.

3.  **Visualisierungen:** Verschiedene Visualisierungen wie Scatterplots oder Liniendiagramme könnten erstellt werden, um Trends oder Muster zwischen Gehalt und Bildungsniveau zu erkennen.

### 6.3.1.: Desktiptive Statistiken:

```{r}
# Bibliotheken laden
library(ggplot2)
library(dplyr)

# Daten berechnen
salary_percentiles <- filtered_data %>%
  group_by(Education.Level) %>%
  summarise(`10th Percentile` = quantile(Salary, probs = 0.1, na.rm = TRUE),
            `25th Percentile` = quantile(Salary, probs = 0.25, na.rm = TRUE),
            `50th Percentile (Median)` = quantile(Salary, probs = 0.5, na.rm = TRUE),
            `75th Percentile` = quantile(Salary, probs = 0.75, na.rm = TRUE),
            `90th Percentile` = quantile(Salary, probs = 0.9, na.rm = TRUE))

# Reshape der Daten für das Plotting
salary_percentiles_long <- salary_percentiles %>%
  tidyr::pivot_longer(cols = -Education.Level, names_to = "Percentile", values_to = "Salary")

# Diagramm erstellen
ggplot(salary_percentiles_long, aes(x = Education.Level, y = Salary, fill = Percentile)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.7) +
  labs(title = "Perzentile des Gehalts nach Bildungsniveau",
       x = "Bildungsniveau",
       y = "Gehalt",
       fill = "Perzentil") +
  theme_minimal()

```

```{r}
# Berechnung der Durchschnittsgehälter pro Bildungsniveau
average_salary_education <- aggregate(Salary ~ Education.Level, data = filtered_data, FUN = mean, na.rm = TRUE)

# Anzeige der Durchschnittsgehälter pro Bildungsniveau
average_salary_education
```

### 6.3.2.: **Boxplots pro Bildungsniveau:**

```{r}
# Bildungsniveau nach aufsteigender Reihenfolge sortieren
filtered_data <- filtered_data %>%
  mutate(Education.Level = factor(Education.Level, levels = unique(sort(Education.Level))))

# Boxplot erstellen
ggplot(filtered_data, aes(x = reorder(factor(Education.Level), Salary, FUN = median), y = Salary)) +
  geom_boxplot(fill = "lightblue", color = "black") +
  labs(title = "Boxplot des Gehalts nach Bildungsniveau",
       x = "Bildungsniveau",
       y = "Gehalt") +
  theme_minimal()
```

### 6.3.3.: **Visualisierungen:**

```{r}
# Bildungsniveau nach aufsteigender Reihenfolge sortieren
filtered_data <- filtered_data %>%
  mutate(Education.Level = factor(Education.Level, levels = unique(sort(Education.Level))))

# Scatterplot erstellen
ggplot(filtered_data, aes(x = reorder(factor(Education.Level), Salary, FUN = median), y = Salary)) +
  geom_point() + 
  labs(title = "Gehalt nach Bildungslevel",
       x = "Bildungslevel",
       y = "Gehalt") +
  theme_minimal()
```

```{r}
# Bildungslevel neu ordnen
filtered_data$Education.Level <- factor(filtered_data$Education.Level, levels = c("0", "1", "2", "3"))

# Liniendiagramm mit umgekehrter Reihenfolge des Bildungsniveaus erstellen
ggplot(filtered_data, aes(x = Education.Level, y = Salary, group = 1)) +
  geom_line() +
  stat_summary(fun.y = median, geom = "point", size = 3, color = "red") +
  labs(title = "Gehalt nach Bildungslevel",
       x = "Bildungslevel",
       y = "Gehalt") +
  theme_minimal()
```

hier diagramm erklären weil anderes aus vorlesung

These Korrekt: Ohne einen Hochschulabschluss gibt es eine Gehaltsgrenze. Die top 90% ohne Hochschulabschluss fangen bei den unteren 10% mit Hochschulabschluss an aus der Sicht des Gehalts.

## 6.4 Technische Jobs haben ein höheres Gehalt als Administrative Jobs

### 6.4.1.: Daten Aufbereiten

Unter dem Punkt Datenaufbereitung wurden zu diesem Zweck alle Jobs in Administrativ und Technisch eingeteilt. Zudem filtern wir noch zusätzlich alle Datensätze raus welche "Director" im Jobtitel enthalten da diese sich nicht auf eine der Kategorisieren eindeutig zuordnen lassen. (z.B. Engineering Director)

```{r}
# Kopie von filtered_data als filtered_data2 erstellen
filtered_data2 <- filtered_data

# Filtern der Daten für Jobs mit "Director" im Jobtitel in filtered_data2
director_jobs <- filtered_data2 %>%
  filter(grepl("Director", Job.Title))

# Entfernen der Zeilen mit "Director" aus filtered_data2
filtered_data2 <- filtered_data2 %>%
  anti_join(director_jobs)
```

```{r}
nrow(director_jobs)
nrow(filtered_data)
nrow(filtered_data2)
```

### 6.4.2.: Insgesamt

Eine Übersicht der durchschnittlichen Gehälter nach der Sortierung von Jobs technischer und adminsitrativer Natur.

```{r}
# Filtern der Daten für technische und administrative Jobs basierend auf den Kriterien
technische_jobs <- subset(filtered_data, job_type == 0)
admin_jobs <- subset(filtered_data, job_type == 1)

# Durchschnittliche Gehälter pro Jobtyp für technische Jobs berechnen
average_salaries_technical <- mean(technische_jobs$Salary, na.rm = TRUE)

# Durchschnittliche Gehälter pro Jobtyp für administrative Jobs berechnen
average_salaries_admin <- mean(admin_jobs$Salary, na.rm = TRUE)

# Zusammenführen der durchschnittlichen Gehälter in einem Datenrahmen
all_average_salaries <- data.frame(Job.Type = c("technisch", "admin"),
                                   Average.Salary = c(average_salaries_technical, average_salaries_admin))

# Erstellung des Diagramms mit angepasster Achsenbeschriftung
ggplot(all_average_salaries, aes(x = Job.Type, y = Average.Salary, fill = Job.Type)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.7) +
  labs(title = "Durchschnittliche Gehälter nach Jobtyp",
       x = "Jobtyp",
       y = "Durchschnittliches Gehalt") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma)  # Verwendung von scales::comma für die Achsenbeschriftung in Tausenden
```

```{r}
# Filtern der Daten für technische und administrative Jobs basierend auf den Kriterien
technische_jobs <- subset(filtered_data, job_type == 0)
admin_jobs <- subset(filtered_data, job_type == 1)

# Durchschnittliche Gehälter pro Jobtyp für technische Jobs berechnen
average_salaries_technical <- mean(technische_jobs$Salary, na.rm = TRUE)

# Durchschnittliche Gehälter pro Jobtyp für administrative Jobs berechnen
average_salaries_admin <- mean(admin_jobs$Salary, na.rm = TRUE)

# Ausgabe der berechneten durchschnittlichen Gehälter mit Beschriftung
cat("Durchschnittliches Gehalt für technische Jobs:", average_salaries_technical, "\n")
cat("Durchschnittliches Gehalt für administrative Jobs:", average_salaries_admin, "\n")

```

### 6.4.3.: Je Land

Eine Übersicht der durchschnittlichen Gehälter nach der Sortierung von Jobs technischer und adminsitrativer Natur aller Länder.

```{r}
#Daten nach Bildungsniveau, Land und Median des Gehalts gruppieren
summary_data <- aggregate(Salary ~ Education.Level + Country, data = filtered_data, FUN = median)

#Balkendiagramm erstellen
ggplot(summary_data, aes(x = Education.Level, y = Salary, fill = Country)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Median Gehalt nach Bildungslevel und Land", 
       x = "Bildungslevel",
       y = "Median Gehalt",
       fill = "Land") +
  theme_minimal()
```

These Korrekt, und das Obwohl in den Admin Jobs auch in seltenen Fällen Manager vertreten sind.

Es lässt sich zudem beobachten das Doktoren in Australien ein höheres Gehalt verdienen als in anderen Ländern.

## 6.5 Data Scientist verdienen aufgrund der hohen Nachfrage der Berufsgruppe im Schnitt mehr Geld als andere Jobgruppen bei gleichbleibender Erfahrung und Abschlussniveau.

### 6.5.1.: Begründung

Data Scientist ist laut dem Harvard Business Review der "Sexiest Job of the 21st Century"\*

\*<https://hbr.org/2012/10/data-scientist-the-sexiest-job-of-the-21st-century>

Bei dieser Aussage haben wir uns gefragt ob sich die Beschreibung auch auf die Gehälter des Data Scientists anwenden lässt.

### 2.: Datenaufbereitung

Rausfiltern aller Manager und Direktoren. Einengung nach Jobs mit dem Stichwort Data, Software, Developer und Engineer

```{r}
# Filtern der Daten für Jobs mit spezifischen Schlüsselwörtern im Jobtitel
filtered_data3 <- filtered_data %>%
  filter(grepl("Data|Software|Developer|Engineer", Job.Title))

# Anzeigen aller eindeutigen Jobtitel und deren Häufigkeit in filtered_data3
job_title_count <- table(filtered_data3$Job.Title)
job_title_df <- data.frame(Job_Title = names(job_title_count), Frequency = as.numeric(job_title_count))

# Anzeige des Dataframes mit den Jobtiteln und deren Häufigkeit
job_title_df

```

```{r}
# Filtern der Daten für Jobs ohne "Director" im Jobtitel
filtered_data3 <- filtered_data3 %>%
  filter(!grepl("Director|Manager", Job.Title))

# Anzeigen aller eindeutigen Jobtitel und deren Häufigkeit in filtered_data3
job_title_count <- table(filtered_data3$Job.Title)
job_title_df <- data.frame(Job_Title = names(job_title_count), Frequency = as.numeric(job_title_count))

# Anzeige des Dataframes mit den Jobtiteln und deren Häufigkeit
job_title_df
```

Aufteilen der Jobs in die Sparte Data & Software

```{r}
# Erstellen der neuen Spalte 'data_job'
filtered_data3 <- filtered_data3 %>%
  mutate(data_job = ifelse(grepl("Data", Job.Title), 1, 0))
```

```{r}
# Zählen der Anzahl von 0 und 1 in der Spalte data_job
count_0 <- sum(filtered_data3$data_job == 0, na.rm = TRUE)
count_1 <- sum(filtered_data3$data_job == 1, na.rm = TRUE)

# Ausgabe der Anzahl von 0 und 1
cat("Anzahl der Zeilen mit dem Wert 0 bei data_job (Data Scientists & Engineers):", count_0, "\n")
cat("Anzahl der Zeilen mit dem Wert 1 bei data_job (Software Engineers & Co):", count_1, "\n")
```

### 6.5.3.: Balkendiagramm

Hierzu teilen wir noch die Arbeitserfahrung in Quartile ein für eine bessere Übersicht. Die Bildungsniveaus sind ja bereits in 4 Werte Unterteilt.

Ich weiß nicht warum aber ich muss das Paket neu laden.

```{r}
# Laden des dplyr-Pakets
library(dplyr)

# Berechnung der Quartile der Berufserfahrung
filtered_data4 <- filtered_data4 %>%
  mutate(Experience_Quartile = ntile(Years.Of.Experience, 4))

# Balkendiagramm für data_job im Vergleich zum Gehalt
ggplot(filtered_data4, aes(x = factor(data_job), y = Salary)) +
  stat_summary(fun = "mean", geom = "bar", position = "dodge", fill = "skyblue") +
  labs(title = "Gehalt nach Data Job",
       x = "Data Job",
       y = "Gehalt (Mittelwert)")

```

```{r}
# Erstellung des Balkendiagramms
ggplot(filtered_data4, aes(y = Salary, x = factor(Experience_Quartile))) +
  geom_bar(stat = "identity", position = "dodge", aes(fill = factor(data_job))) +
  labs(title = "Quartile der Berufserfahrung nach Gehalt und Jobtyp",
       x = "Quartile der Berufserfahrung",
       y = "Gehalt") +
  theme_minimal()

```

Bildungsniveau Codes:

0 = High School Abschluss

1 = Bachelor

2 = Master

3 = Doctor

```{r}
# Erstellung des Balkendiagramms für Education Level
ggplot(filtered_data4, aes(y = Salary, x = factor(Education.Level))) +
  geom_bar(stat = "identity", position = "dodge", aes(fill = factor(data_job))) +
  labs(title = "Quartile des Bildungsniveaus nach Gehalt und Jobtyp",
       x = "Quartile des Bildungsniveaus",
       y = "Gehalt") +
  theme_minimal()
```

Im Mittel verdienen Data Scientists mehr als Arbeitnehmer aus der Software Engineering & Co Gruppe. Wobei man beobachten kann das die Gruppe Data mindestens einen Bachelor bestitzt und erst ab dem Master mehr verdient als ihr counterpart. Bezüglich der Berufserfahrung lässt sich feststellen das es in jedem Quartil ein höheres Gehaltsniveau bei der Gruppe Data gibt.

## 6.6 Die Gehälter sind höher in Ländern mit höheren BIP pro Kopf

Da dieses Land staistisch mehr Geld pro Einwohner erwirtschaftet.

BIP pro Kopf (2023):

Australien 64.813,85 US-Dollar Quelle: [Australien - BIP pro Kopf bis 2028 \| Statista](https://de.statista.com/statistik/daten/studie/14425/umfrage/bruttoinlandsprodukt-pro-kopf-in-australien/#:~:text=Im%20Jahr%202022%20hat%20das%20Bruttoinlandsprodukt%20pro%20Kopf,Kopf%20in%20Australien%20auf%20rund%2063.487%2C05%20US-Dollar%20prognostiziert. "https://de.statista.com/statistik/daten/studie/14425/umfrage/bruttoinlandsprodukt-pro-kopf-in-australien/#:~:text=im%20jahr%202022%20hat%20das%20bruttoinlandsprodukt%20pro%20kopf,kopf%20in%20australien%20auf%20rund%2063.487%2c05%20us-dollar%20prognostiziert.")

Canada 53.246,98 US-Dollar Quelle: [Kanada - BIP pro Kopf bis 2028 \| Statista](https://de.statista.com/statistik/daten/studie/14428/umfrage/bruttoinlandsprodukt-pro-kopf-in-kanada/#:~:text=Im%20Jahr%202022%20hat%20das%20Bruttoinlandsprodukt%20pro%20Kopf,bis%202022%20und%20Prognosen%20bis%20zum%20Jahr%202028. "https://de.statista.com/statistik/daten/studie/14428/umfrage/bruttoinlandsprodukt-pro-kopf-in-kanada/#:~:text=im%20jahr%202022%20hat%20das%20bruttoinlandsprodukt%20pro%20kopf,bis%202022%20und%20prognosen%20bis%20zum%20jahr%202028.")

China 12.541,40 US-Dollar Quelle: [China - BIP pro Kopf bis 2028 \| Statista](https://de.statista.com/statistik/daten/studie/19407/umfrage/bruttoinlandsprodukt-pro-kopf-in-china/#:~:text=Im%20Jahr%202022%20hat%20das%20Bruttoinlandsprodukt%20pro%20Kopf,bis%202022%20und%20Prognosen%20bis%20zum%20Jahr%202028. "https://de.statista.com/statistik/daten/studie/19407/umfrage/bruttoinlandsprodukt-pro-kopf-in-china/#:~:text=im%20jahr%202022%20hat%20das%20bruttoinlandsprodukt%20pro%20kopf,bis%202022%20und%20prognosen%20bis%20zum%20jahr%202028.")

UK 48.912,78 US-Dollar Quelle: [Großbritannien - BIP pro Kopf bis 2028 \| Statista](https://de.statista.com/statistik/daten/studie/14453/umfrage/bruttoinlandsprodukt-pro-kopf-in-grossbritannien/#:~:text=F%C3%BCr%20das%20Jahr%202023%20wird%20das%20Bruttoinlandsprodukt%20pro,bis%202020%20und%20Prognosen%20bis%20zum%20Jahr%202028. "https://de.statista.com/statistik/daten/studie/14453/umfrage/bruttoinlandsprodukt-pro-kopf-in-grossbritannien/#:~:text=f%c3%bcr%20das%20jahr%202023%20wird%20das%20bruttoinlandsprodukt%20pro,bis%202020%20und%20prognosen%20bis%20zum%20jahr%202028.")

USA 76.343 US-Dollar Quelle: [USA - BIP pro Kopf bis 2028 \| Statista](https://de.statista.com/statistik/daten/studie/14454/umfrage/bruttoinlandsprodukt-pro-kopf-in-den-usa/ "https://de.statista.com/statistik/daten/studie/14454/umfrage/bruttoinlandsprodukt-pro-kopf-in-den-usa/")

### 6.6.1.: Aufbereitung

```{r}
# Erstelle eine neue Spalte "BIP_Per_Person" mit NA-Werten
filtered_data3$BIP_Per_Person <- NA

# Weise den genannten Ländern die entsprechenden BIP-Werte zu
filtered_data3$BIP_Per_Person[filtered_data3$Country == "Australia"] <- 64813.85
filtered_data3$BIP_Per_Person[filtered_data3$Country == "Canada"] <- 53246.98
filtered_data3$BIP_Per_Person[filtered_data3$Country == "China"] <- 12541.40
filtered_data3$BIP_Per_Person[filtered_data3$Country == "UK"] <- 48912.78
filtered_data3$BIP_Per_Person[filtered_data3$Country == "USA"] <- 76343.00

```

```{r}
head(filtered_data3)
```

Hat funktioniert.

### 6.6.2.: Scatterplot

```{r}
# Scatterplot mit Farbgebung nach Ländern und Mittelwerten einzeichnen
ggplot(filtered_data3, aes(x = BIP_Per_Person, y = Salary, color = Country)) +
  geom_point() +
  stat_summary(fun = mean, geom = "point", shape = 23, size = 3, fill = "black") +
  labs(title = "Vergleich von Gehalt und BIP pro Person nach Ländern",
       x = "BIP pro Person",
       y = "Gehalt",
       color = "Land") 
```

```{r}
# Berechnung der Mittelwerte nach Land
mean_salaries_by_country <- filtered_data3 %>%
  group_by(Country) %>%
  summarise(mean_salary = mean(Salary, na.rm = TRUE))

# Ausgabe der Mittelwerte nach Land
mean_salaries_by_country
```

```{r}
# Installation des dplyr-Pakets
install.packages("dplyr")

# Laden des dplyr-Pakets
library(dplyr)

# Berechnung der Mittelwerte nach Land
mean_salaries_by_country <- filtered_data3 %>%
  group_by(Country) %>%
  summarise(mean_salary = mean(Salary, na.rm = TRUE),
            BIP_Per_Person = first(BIP_Per_Person))  # Annahme: BIP-Pro-Person-Werte sind konstant für jedes Land

# Ausgabe der Mittelwerte nach Land mit BIP pro Person
mean_salaries_by_country

```

```{r}
cor(filtered_data3$Salary, filtered_data3$BIP_Per_Person, use = "complete.obs")

```

Nun ohne China

```{r}
# Erstellen des neuen Datensatzes ohne Einträge für China
filtered_data3_no_china <- filtered_data3 %>% filter(Country != "China")
```

```{r}
cor(filtered_data3_no_china$Salary, filtered_data3_no_china$BIP_Per_Person, use = "complete.obs")
```

```{r}
# Anzahl der Datensätze mit dem Land "China" im Datensatz filtered_data3_no_china
count_china <- filtered_data3_no_china %>% filter(Country == "China") %>% nrow()
count_china
```

These nicht korrekt. Es scheint so als gibt es eine negative Korrelation zwischen dem Gehalt welches ein Arbeitnehmer erhält und dem BIP des jeweiligen Landes. Selbst wenn man China aus der Rechnung rausnimmt welches aufgrund der ungewöhnlich hohen Einwohnerzahl und diversen Wirtschaft (Sonderverwaltungszonen und Kommunismus\*) einen sehr niedrigen BIP hat aber trotzdem hohe Gehälter.

\*<https://de.wikipedia.org/wiki/Politisches_System_der_Volksrepublik_China>

\*<https://de.wikipedia.org/wiki/Sonderverwaltungszone>

# 7. Regressionen

## 7.1.: Gehalt und Arbeitserfahrung

Lineare Regression einer abhängigen Variable (Gehalt) anhand einer unabhängigen Variable (Jahre an Erfahrung)

```{r}
# Z-Skalierung der Variable "Years.Of.Experience"
filtered_data3_z <- filtered_data3
filtered_data3_z$Years.Of.Experience <- scale(filtered_data3$Years.Of.Experience)

# Lineare Regression von "Salary" basierend auf "Years.Of.Experience"
lm_model <- lm(Salary ~ Years.Of.Experience, data = filtered_data3_z)

# Zusammenfassung der Regression
summary(lm_model)

```

```{r}
# Scatterplot mit der Regressionslinie
# ggplot(filtered_data3_z, aes(x = Years.Of.Experience, y = Salary)) +
#   geom_point() +
#   geom_smooth(method = "lm", se = FALSE, color = "blue") +
#   labs(title = "Lineare Regression von Salary und Years of Experience (Z-Scale)",
#        x = "Years of Experience (Z-Scale)",
#        y = "Salary")

```

"Fehler in ggplot(filtered_data3_z, aes(x = Years.Of.Experience, y = Salary)) : konnte Funktion"ggplot" nicht finden"

```{r}
#Ich weiß nicht warum aber an dieser Stelle muss man die library ggplot2 erneut laden.
library(ggplot2)
# Scatterplot mit der Regressionslinie
ggplot(filtered_data3_z, aes(x = Years.Of.Experience, y = Salary)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(title = "Lineare Regression von Salary und Years of Experience (Z-Scale)",
       x = "Years of Experience (Z-Scale)",
       y = "Salary")

```

Bitte komplett umschreiben in "einfach" Danke \<3. Referenz von den punkten (1., 2. usw auf die folien/skript nehmen)

\
Dieses Ergebnis ist die Zusammenfassung einer linearen Regressionsanalyse zwischen dem Gehalt (Salary) und der Erfahrung in Jahren (Years.Of.Experience) basierend auf den vorher skalierten Daten. Hier sind einige wichtige Punkte:

1.  **Residuen (Residuals):** Die Residuen sind die Differenzen zwischen den beobachteten und den geschätzten Gehaltswerten. Sie zeigen, wie weit die tatsächlichen Gehälter von den vorhergesagten Gehältern entfernt sind. Der kleinste Residual (Min) beträgt -135697, der größte (Max) 85976, und die anderen Quartile sind ebenfalls aufgelistet.

2.  **Koeffizienten (Coefficients):** Die Koeffizienten der Regression zeigen die geschätzten Auswirkungen der unabhängigen Variable (Years.Of.Experience) auf die abhängige Variable (Salary). Der Intercept (Konstante) beträgt 122055.8, was das geschätzte Gehalt für eine Person mit null Jahren Erfahrung wäre. Der Koeffizient für Years.Of.Experience beträgt 36340.8, was bedeutet, dass das geschätzte Gehalt um 36340.8 Einheiten steigt, wenn sich die Jahre der Erfahrung um eine Einheit erhöhen.

3.  **Signifikanz der Koeffizienten:** Die Werte unter "Pr(\>\|t\|)" zeigen die Signifikanz der Koeffizienten an. Für beide Koeffizienten (\<2e-16) ist der p-Wert sehr klein, was darauf hinweist, dass die Beziehung zwischen Gehalt und Jahren der Erfahrung statistisch signifikant ist.

4.  **Residuelle Standardabweichung:** Dies ist ein Maß für die durchschnittliche Abweichung der beobachteten Gehälter von den geschätzten Gehältern durch das Modell. In diesem Fall beträgt sie 31470.

5.  **Bestimmtheitsmaß (R-squared):** Das R-squared oder Bestimmtheitsmaß misst, wie gut die unabhängige Variable die Variation der abhängigen Variable erklärt. In diesem Fall beträgt das Adjusted R-squared 0.5714, was bedeutet, dass etwa 57% der Variation im Gehalt durch die Jahre der Erfahrung erklärt werden kann.

6.  **F-Statistik:** Die F-Statistik testet, ob mindestens eine der unabhängigen Variablen signifikant zur Erklärung der Variation der abhängigen Variable beiträgt. Ein hoher Wert und ein kleiner p-Wert (hier \< 2.2e-16) deuten darauf hin, dass das Modell insgesamt signifikant ist.

!Mehrere Variablen auf Gehalt beziehen siehe beispiel ozone

!Es fehlt: correlation und corrplot

!Aufteilung in Test- und Trainingsdaten:

!Vorhersagen auf Trainings- und Testdatensatz:

!Trainingsfehler:

!Zur Einordnung der Fehler die Verteilung von Gehalt ansehen:

## 7.2.:
